<!--
    DAC - Dynamic Audio Codec, a lossy audio codec written by MINT: https://www.youtube.com/@__MINT_
    Offers compression better than MP3 while being less computationally heavy. DAC comes as a complete
    audio encoding / decoding browser environment and allows to tune some advanced encoding parameters
    to maximize performance. Supports wide range of bitrates, sample rates and audio channels. DAC is
    fully VBR and doesn't have any CBR mode, so it is not intended for hitting a target bitrate. Audio
    quality setting is provided by the user instead.

    eDAC - Enhanced Dynamic Audio Codec offering quality much better than DAC is currently in development.
    Stay tuned!

    And keep in mind, that DAC software comes with absolutely no warranty! If you're hacking it and
    it blows up your ears, I am not responsible for that.
-->


<!DOCTYPE html>
<html lang="en-EN">
<head>
<meta charset="UTF-8">
<title>DAC</title>
<link rel="shortcut icon" href="graphics/note.png">
<link rel="stylesheet" href="sources/UI.css">
<script src="sources/loadWave.js" type="text/javascript"></script>
<script src="sources/createFile.js" type="text/javascript"></script>
<script src="sources/coreFunctions.js" type="text/javascript"></script>
<script src="sources/lookups.js" type="text/javascript"></script>
<script type="text/javascript">

let audioBuffer;
let encodedBuffer;
let decodedBuffer;
let sampleRate = 0;
let audioChannels = 0;
let channelSamples = 0;
let dataWidth = 0;
let waveSize = 0;
let audioDuration = 0;
let loadedName = "";
let wasLoaded = false;
let wasEncoded = false;
let busyLoading = false;
let busyEncoding = false;
let busyPreview = false;
let encoder;
let parser;
let loader;
let haltTimeout;
let prevListener1;
let prevListener2;
let monitorRefresh = 0.15;


const mainPart1 = new Blob([lookupString], {type: "application/javascript"});
const mainPart2 = new Blob([coreFunctionString], {type: "application/javascript"});
const mainPart3 = new Blob([encoderString], {type: "application/javascript"});
const mainPart4 = new Blob([waveLoaderString], {type: "application/javascript"});
const fileEncoder = URL.createObjectURL(new Blob([mainPart1, mainPart2, mainPart3], {type: "application/javascript"}));
const waveLoader = URL.createObjectURL(new Blob([mainPart1, mainPart4], {type: "application/javascript"}));

window.addEventListener('pageshow', function(event)
 {
 retreiveEncodingParams(false);
 });

function id(what)
 {
 return document.getElementById(what);
 }

function run()
 {
 id("loadNew").addEventListener("click", function()
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  id("sound").click();
  });
 const sliderIDs = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 for(let i=0; i<6; i++)
  {
  let currID = sliderIDs[i];
  id(currID).addEventListener("input", function()
   {
   getPreset(i, true);
   });
  id(currID).addEventListener("mousewheel", function(event)
   {
   let dec = event.deltaY > 0;
   if(isBorder(i, dec))
    {
	return;
	}
   let now = rawVal(i);
   let step = i == 5 ? 0.05 : 1;
   dec ? now -= step : now += step;
   this.value = now;
   getPreset(i, true);
   }, {passive: true});
  }
 id("enc").addEventListener("click", function()
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  if(!wasLoaded)
   {
   fileInfo("No file provided.", 4000, "#fff", "No file loaded...", "#777");
   return;
   }
  encodeAudio();
  });
 id("play").addEventListener("click", function(event)
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  if(!wasLoaded)
   {
   fileInfo("No file provided.", 4000, "#fff", "No file loaded...", "#777");
   return;
   }
  realTimePlayback();
  });
 id("downFile").addEventListener("click", function()
  {
  if(wasEncoded)
   {
   id("dacFile").click();
   }
  });
 id("downPrev").addEventListener("click", function()
  {
  if(wasEncoded)
   {
   id("wavFile").click();
   }
  });
 id("advanced").addEventListener("click", checkAdvanced);
 id("monitor").addEventListener("mousewheel", function(event)
  {
  if(!busyPreview)
   {
   return;
   }
  let zoomStep = monitorRefresh < 0.156 ? 0.005 : 0.02;
  if(event.deltaY < 0)
   {
   if(monitorRefresh > 0.041)
    {
    monitorRefresh -= zoomStep;
    }
   return;
   }
  if(monitorRefresh < 0.39)
   {
   monitorRefresh += zoomStep;
   }
  }, {passive: true});
 id("sound").addEventListener("input", function()
  {
  fileLoad(true);
  wasLoaded = false;
  inputFile(false);
  viewInfo(true);
  loader = new FileReader();
  let audio = this.files[0];
  this.value = null;
  if(audio === undefined)
   {
   fileInfo("An unknown error occurred.", 4000, "#ff0000", "No file loaded...", "#777");
   fileLoad(false);
   return;
   }
  fileInfo("Processing...", 0, "#aaa");
  loadedName = audio.name;
  let ext = loadedName.lastIndexOf(".");
  let extension = "";
  if(ext != -1)
   {
   extension = loadedName.substring(ext + 1);
   loadedName = loadedName.substring(0, ext);
   }
  loader.readAsArrayBuffer(audio);
  haltTimeout = setTimeout(function()
   {
   loader.abort();
   viewInfo(false, "Fatal error: loader did not respond", "#ff0000");
   fileInfo("No file loaded...", 0, "#777");
   fileLoad(false);
   }, 30000);
  loader.onload = function()
   {
   let useWorker = (extension == "wav" || extension == "dac");
   clearTimeout(haltTimeout);
   haltTimeout = setTimeout(function()
    {
	if(useWorker){parser.terminate()};
	viewInfo(false, "Fatal error: loader did not respond", "#ff0000");
	fileInfo("No file loaded...", 0, "#777");
	fileLoad(false);
    }, 30000);
   let data = new Uint8Array(loader.result);
   if(useWorker)
    {
    parser = new Worker(waveLoader);
    parser.postMessage({type: extension, raw: data.buffer}, [data.buffer]);
    parser.onmessage = function(event)
     {
	 let feedback = event.data;
	 if(feedback.type == "error")
	  {
	  fileInfo(feedback.desc, 4000, "#ff0000", "No file loaded...", "#777");
	  }
	 else
	  {
	  wasLoaded = true;
	  audioBuffer = new Int32Array(feedback.audio);
	  let parameters = feedback.config;
	  sampleRate = parameters.sRate;
	  audioChannels = parameters.audioCh;
	  dataWidth = parameters.dSize;
	  waveSize = parameters.tSize;
	  audioDuration = parameters.len;
	  channelSamples = parameters.sPerCh;
	  fileInfo(loadedName, 0, "#fff");
	  let channelInfo = "";
	  switch(audioChannels)
	   {
	   case 1:{channelInfo = "mono";}break;
	   case 2:{channelInfo = "stereo";}break;
	   default:{channelInfo = parameters.audioCh;}break;
	   }
	  let basicInfo = "Sampling rate: " + formatSampling(sampleRate) + "; channels: " + channelInfo;
	  viewInfo(false, basicInfo, "#fff");
	  previewInfo(false, 0, audioDuration);
	  cleanBuffers();
	  inputFile(true);
	  if(id("autoLoad").checked)
	   {
	   for(let i=0; i<6; i++)
	    {
	    id("meta" + i).value = feedback.metaData[i].trim();
	    }
	   }
	  }
	 clearTimeout(haltTimeout);
	 parser.terminate();
	 fileLoad(false);
	 }
    parser.onerror = function(event)
     {
     clearTimeout(haltTimeout);
	 parser.terminate();
	 viewInfo(false, event.message, "#ff0000");
     fileInfo("No file loaded...", 0, "#777");
	 fileLoad(false);
	 }
    }
   else
    {
	let decoder;
	try
	 {
	 decoder = new AudioContext();
	 }
	catch
	 {
	 decodingError("Failed to initialize the decoder");
	 clearTimeout(haltTimeout);
	 return;
	 }
    decoder.decodeAudioData(data.buffer,
    function(result)
     {
	 let verifySampling = result.sampleRate;
	 let verifyChannels = result.numberOfChannels;
	 let verifyLength = result.length;
	 if(verifyChannels < 1 || verifyChannels > 256 || verifySampling < 1 || verifySampling > 1000000)
	  {
	  decodingError("Invalid audio parameters");
	  clearTimeout(haltTimeout);
	  return;
	  }
	 if(verifyLength * verifyChannels > 536870912)
      {
      decodingError("Too long audio");
      clearTimeout(haltTimeout);
	  return;
      }
	 wasLoaded = true;
	 sampleRate = verifySampling;
	 audioChannels = verifyChannels;
	 dataWidth = 2;
	 waveSize = verifyLength * verifyChannels * 2 + 44;
	 audioDuration = result.duration;
	 channelSamples = verifyLength;
	 audioBuffer = new Int32Array(verifyLength * audioChannels);
	 for(let i=0; i<audioChannels; i++)
	  {
	  let singleChannel = result.getChannelData(i);
	  let samplePointer = i;
	  for(let j=0; j<verifyLength; j++)
	   {
	   audioBuffer[samplePointer] = singleChannel[j] * 32768;
	   samplePointer += audioChannels;
	   }
	  }
	 fileInfo(loadedName, 0, "#fff");
	 let channelInfo = "";
	 switch(audioChannels)
	  {
	  case 1:{channelInfo = "mono";}break;
	  case 2:{channelInfo = "stereo";}break;
	  default:{channelInfo = parameters.audioCh;}break;
	  }
	 let basicInfo = "Sampling rate: " + formatSampling(sampleRate) + "; channels: " + channelInfo;
	 viewInfo(false, basicInfo, "#fff");
	 previewInfo(false, 0, audioDuration);
	 cleanBuffers();
	 clearTimeout(haltTimeout);
	 inputFile(true);
	 fileLoad(false);
	 },
    function()
	 {
	 decodingError("Unable to decode the file");
	 });
	}
   function decodingError(msg)
    {
	clearTimeout(haltTimeout);
	fileInfo(msg, 4000, "#ff0000", "No file loaded...", "#777");
	fileLoad(false);
	}
   }
  });
 window.addEventListener("keydown", function(event)
  {
  if(event.repeat)
   {
   return;
   }
  let pressed = event.code;
  let isCtrl = event.ctrlKey;
  let isShift = event.shiftKey;
  switch(pressed)
   {
   case "KeyS":
    {
	if(isCtrl)
	 {
	 if(event.cancelable)
	  {
	  event.preventDefault();
	  }
	 if(isShift)
	  {
	  localStorage.removeItem("DAC_settings");
	  console.log("Restored to defaults!");
	  }
	 else
	  {
	  retreiveEncodingParams(true);
	  console.log("Saved!");
	  }
	 }
	}
   break;
   case "Space":
    {
	if(!(/^meta/).test(event.target.id) && event.cancelable)
	 {
	 event.preventDefault();
	 }
	}
   }
  });
 rescale();
 }


function encodeAudio()
 {
 busyEncoding = true;
 retreiveEncodingParams(true);
 cleanBuffers();
 encoder = new Worker(fileEncoder);
 let configData = {
	type: "config",
	values: getEncodingParams()
 };
 let isCursor = false;
 let lastPos = 0;
 let topVal = 1;
 let bottomVal = 0;
 let bitrates = [];
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 id("prBar").value = "0";
 id("monitor").removeEventListener("mousemove", prevListener1);
 id("monitor").removeEventListener("mouseout", prevListener2);
 id("monitor").addEventListener("mousemove", monitorInfo);
 id("monitor").addEventListener("mouseout", cursorLeave);
 prevListener1 = monitorInfo;
 prevListener2 = cursorLeave;
 let audioData = {type: "audio", audio: audioBuffer.buffer, chSamples: channelSamples};
 encoder.postMessage(configData);
 encoder.postMessage(audioData, [audioBuffer.buffer]);
 encoder.postMessage({type: "encode"});
 changeUI(true);
 haltTimeout = setTimeout("responseError()", 60000);
 let start = performance.now();
 let progressNow = 0;
 let dataReceived = 0;
 encoder.onmessage = function(event)
  {
  clearTimeout(haltTimeout);
  haltTimeout = setTimeout("responseError()", 60000);
  let received = event.data;
  if(received.type == "received")
   {
   dataReceived++;
   return;
   }
  if(dataReceived != 2)
   {
   clearTimeout(haltTimeout);
   responseError();
   return;
   }
  switch(received.type)
   {
   case "progress":
    {
	let percent = received.value;
    let runTime = performance.now() - start;
    id("prBar").value = percent;
    if(percent != 0)
     {
     let estimated = Math.round(((100 / percent) - 1) * runTime / 1000);
	 id("progInfo").innerHTML = percent + "% / " + formatTime(estimated) + " left";
     }
	}
   break;
   case "bitrate":
    {
	if(bitrates.length >= 400)
	 {
	 bitrates.shift();
	 }
	bitrates.push(received.value);
	if(bitrates.length > 1)
	 {
	 let graphPoints = scaleGraph(bitrates);
	 topVal = graphPoints.lineMax;
	 bottomVal = graphPoints.lineMin;
	 if(Math.abs(topVal - bottomVal) < 1)
	  {
	  topVal++;
	  }
	 drawGraph(graphPoints.scaled);
	 id("monAverage").innerHTML = "Average: " + graphPoints.average.toFixed(2) + "kbps";
	 if(isCursor)
	  {
	  let b = topVal;
	  let a = (bottomVal - topVal) / 84;
	  let at = a * lastPos + b;
	  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
	  }
	 }
	}
   break;
   case "terminated":
    {
	clearTimeout(haltTimeout);
	audioBuffer = new Int32Array(received.audio);
    encoder.terminate();
    let compressedSize = received.size;
    let avgBitrate = received.bitrate;
	let compRatio = received.ratio;
    let resultString = "Size: " + formatSize(compressedSize) + " (x" + compRatio + ")&nbsp&nbsp&nbspAverage bitrate: " + avgBitrate + "kbps";
    viewInfo(false, resultString, "#fff");
    id("prBar").value = "100";
    id("progInfo").innerHTML = "100% / 0s left";
	const createdFile = new Blob([received.compressed], {type: "application/octet-stream"});
	const previewFile = new Blob([received.wavePreview], {type: "audio/wav"});
    const dacURL = URL.createObjectURL(createdFile);
	const wavURL = URL.createObjectURL(previewFile);
	id("dacFile").setAttribute("download", loadedName.trim() + ".dac");
	id("dacFile").setAttribute("href", dacURL);
	id("wavFile").setAttribute("download", loadedName.trim() + ".wav");
	id("wavFile").setAttribute("href", wavURL);
	wasEncoded = true;
	downloads(true);
	busyEncoding = false;
	setTimeout("changeUI(false)", 1000);
	}
   break;
   case "error":
    {
	clearTimeout(haltTimeout);
	audioBuffer = new Int32Array(received.audio);
	viewInfo(false, received.desc, "#ff0000");
	busyEncoding = false;
	setTimeout("changeUI(false)", 1000);
	}
   break;
   }
  }
 encoder.onerror = function(event)
  {
  clearTimeout(haltTimeout);
  viewInfo(false, event.message, "#ff0000");
  encoder.terminate();
  wasLoaded = false;
  inputFile(false);
  fileInfo("No file loaded...", 0, "#777");
  busyEncoding = false;
  setTimeout("changeUI(false)", 1000);
  }
 function monitorInfo(event)
  {
  isCursor = true;
  let y = event.offsetY - 4;
  if(y < 0){y = 0;}
  else if(y > 84){y = 84;}
  lastPos = y;
  let b = topVal;
  let a = (bottomVal - topVal) / 84;
  let at = a * y + b;
  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
  }
 function cursorLeave()
  {
  isCursor = false;
  id("monCursor").innerHTML = "Cursor: ---";
  }
 }

function scaleGraph(lineData)
 {
 let lineMax = Math.max.apply(Math, lineData);
 let lineMin = Math.min.apply(Math, lineData);
 if(lineMax - lineMin < 1)
  {
  return {scaled: lineData, average: lineData[0] / 1000, lineMax: lineData[0], lineMin: lineData[0]};
  }
 let scaled = [];
 let average = 0;
 let points = lineData.length;
 let a = 249 / (lineMin - lineMax);
 let b = -a * lineMax;
 for(let i=0; i<points; i++)
  {
  average += lineData[i];
  scaled.push(a * lineData[i] + b);
  }
 average /= points * 1000;
 return {scaled, average, lineMax, lineMin};
 }

function drawGraph(lineData)
 {
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 monitor.beginPath();
 monitor.moveTo(0, lineData[0]);
 for(let i=1; i<lineData.length; i++)
  {
  monitor.lineTo(i * 5, lineData[i]);
  }
 monitor.strokeStyle = "white";
 monitor.lineWidth = "4";
 monitor.lineCap = "square";
 monitor.lineJoin = "miter";
 monitor.miterLimit = "1";
 monitor.stroke();
 }

function responseError()
 {
 encoder.terminate();
 wasLoaded = false;
 inputFile(false);
 fileInfo("No file loaded...", 0, "#777");
 viewInfo(false, "Fatal error: encoder stopped responding", "#ff0000");
 previewInfo(true);
 busyEncoding = false;
 setTimeout("changeUI(false)", 1000);
 }

function previewError()
 {
 encoder.terminate();
 wasLoaded = false;
 inputFile(false);
 fileInfo("No file loaded...", 0, "#777");
 previewInfo(true);
 busyPreview = false;
 viewInfo(false, "Fatal error: encoder stopped responding", "#ff0000");
 UIforPreview(false);
 }

function getEncodingParams()
 {
 let sliderPos = [96, 0, 0, 0, 800, getPreset(5, false)];
 let fieldSel = [2, 1, 2, 1];
 if(sliderPos[5] > 100 || sliderPos[5] < 0)
  {
  sliderPos[5] = 15;
  }
 if(id("advanced").checked)
  {
  const upperLimits = [120, 24000, 10000, 10000, 2000];
  const lowerLimits = [48, 3000, 0, 0, 0];
  const fieldLim = [3, 3, 5, 1];
  for(let i=0; i<5; i++)
   {
   if(id("apply" + i).checked)
    {
	let preset = getPreset(i, false);
	if(preset > upperLimits[i] || preset < lowerLimits[i])
	 {
	 continue;
	 }
	sliderPos[i] = preset;
	}
   }
  for(let i=0; i<4; i++)
   {
   let selected = fieldVal(i);
   if(selected <= fieldLim[i] && selected >= 0)
    {
	fieldSel[i] = selected;
	}
   }
  }
 const correspond = [[15, 8, 2.5, 1.25], [4, 8, 16, 32], [0.5, 1, 2, 5, 10, 30]];
 for(let i=0; i<3; i++)
  {
  fieldSel[i] = correspond[i][fieldSel[i]];
  }
 let applyMeta = id("inclMeta").checked;
 let addMeta = [];
 if(applyMeta && !busyPreview)
  {
  for(let i=0; i<6; i++)
   {
   addMeta.push(id("meta" + i).value.trim());
   }
  }
 return {
	quality: sliderPos[5],
	rate: sampleRate,
	bitDepth: dataWidth,
	channels: audioChannels,
	dynaRange: sliderPos[0],
	freqRange: sliderPos[1],
	upBitLim: sliderPos[2],
	loBitLim: sliderPos[3],
	lowFreqRange: sliderPos[4],
	transientSens: fieldSel[0],
	subbandSize: fieldSel[1],
	keyframeInt: fieldSel[2],
	adaptAlloc: fieldSel[3],
	origSize: waveSize,
	includeMeta: applyMeta,
	fileMetaData: addMeta
  };
 }
 
function retreiveEncodingParams(store)
 {
 const topLimits = [100, 1, 1, 1, 120, 210, 200, 200, 200, 3, 3, 5, 1, 1, 1, 1, 1, 1];
 const bottomLimits = [0, 0, 0, 0, 48, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
 const defaults = [15, 1, 1, 0, 96, 146, 54, 10, 80, 2, 1, 2, 1, 0, 0, 0, 0, 0];
 const fieldIDs = ["qual", "autoLoad", "inclMeta", "advanced", "dnRange", "ctFreq", "upLim", "loLim", "impFreq", "transientField", "subbandField", "keyframeField", "adaptAllocApply", "apply0", "apply1", "apply2", "apply3", "apply4"];
 const fieldTypes = [false, true, true, true, false, false, false, false, false, false, false, false, true, true, true, true, true, true];
 const storedNames = ["quality", "loadMetaFromFile", "includeMetaInFile", "advancedPanel", "dynamicRange", "cutoffFrequency", "upperBitLimit", "lowerBitLimit", "lowerFrequencies", "transientSensitivity", "subbandSize", "keyframeInterval", "adaptiveAllocation", "customDynamicRange", "customCutoff", "customUpperLim", "customLowerLim", "customLowerFreq"];
 let allPresets = {};
 if(store)
  {
  for(let i=0; i<storedNames.length; i++)
   {
   let setNow = fieldTypes[i] ? id(fieldIDs[i]).checked + 0 : id(fieldIDs[i]).value;
   let parsed = parseFloat(setNow);
   if(isNaN(setNow))
    {
    allPresets[storedNames[i]] = defaults[i];
    continue;
    }
   if(setNow < bottomLimits[i] || setNow > topLimits[i])
    {
    allPresets[storedNames[i]] = defaults[i];
    continue;
    }
   allPresets[storedNames[i]] = setNow;
   }
  if(monitorRefresh < 0.039 || monitorRefresh > 0.41)
   {
   monitorRefresh = 0.15;
   }
  allPresets.monitorRefreshRate = monitorRefresh;
  localStorage.setItem("DAC_settings", JSON.stringify(allPresets));
  return;
  }
 const pattern = /^^{("[a-zA-Z0-9]+":"?[0-9\.]+"?\,?)*}$/g;
 let settingString = localStorage.getItem("DAC_settings");
 if(!pattern.test(settingString))
  {
  retreiveEncodingParams(true);
  return;
  }
 allPresets = JSON.parse(settingString);
 for(let i=0; i<storedNames.length; i++)
  {
  let stored = parseFloat(allPresets[storedNames[i]]);
  let newVal = 0;
  if(isNaN(stored))
   {
   newVal = defaults[i];
   }
  else if(stored < bottomLimits[i] || stored > topLimits[i])
   {
   newVal = defaults[i];
   }
  else
   {
   newVal = stored;
   }
  fieldTypes[i] ? id(fieldIDs[i]).checked = newVal : id(fieldIDs[i]).value = newVal;
  }
 for(let i=0; i<6; i++)
  {
  getPreset(i, true);
  }
 checkAdvanced();
 let storedRefresh = parseFloat(allPresets.monitorRefreshRate);
 if(isNaN(storedRefresh))
  {
  monitorRefresh = 0.15;
  return;
  }
 if(storedRefresh < 0.039 || storedRefresh > 0.41)
  {
  monitorRefresh = 0.15;
  return;
  }
 monitorRefresh = storedRefresh;
 }


function realTimePlayback()
 {
 const minFrameDur = 1500 / sampleRate;
 let fragLen = Math.max(minFrameDur, 0.05);
 let realTimePlayer;
 let playBuffer;
 let currentBuffer;
 let audioTime = 0;
 let playerTime = 0;
 let prevTime = 1;
 let firstFrame = true;
 let seek = false;
 let wasStopped = false;
 let nextReady = true;
 let usedChannels = audioChannels > 1 ? 2 : 1;
 if(audioDuration < fragLen)
  {
  viewInfo(false, "Error: too short audio", "#ff0000");
  return;
  }
 if(id("resInfo").style.color = "#ff0000")
  {
  id("resInfo").innerHTML = "";
  }
 try
  {
  realTimePlayer = new AudioContext({sampleRate});
  }
 catch(error)
  {
  let shorten = error.toString();
  if(shorten.length > 100)
   {
   shorten = shorten.slice(0, 97) + "...";
   }
  viewInfo(false, 'Error while setting up playback.<br><span style="font-size:10px; display:block">' + shorten + '</span>', "#ff0000");
  return;
  }
 busyPreview = true;
 UIforPreview(true);
 let bitrates = [];
 let sumTime = 0;
 let sumVal = 0;
 let sumFrames = 0;
 let topVal = 1;
 let bottomVal = 0;
 let isCursor = false;
 let lastPos = 0;
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 encoder = new Worker(fileEncoder);
 let configData = {type: "config", values: getEncodingParams()};
 let audioData = {type: "audio", audio: audioBuffer.buffer, chSamples: channelSamples};
 encoder.postMessage(configData);
 encoder.postMessage(audioData, [audioBuffer.buffer]);
 encoder.postMessage({type: "slice", startFrom: 0, fragment: fragLen});
 haltTimeout = setTimeout("previewError()", 5000);
 id("forw").addEventListener("mousedown", seekForw);
 id("rev").addEventListener("mousedown", seekRev);
 id("play").addEventListener("mouseup", stopRequest);
 id("monitor").addEventListener("contextmenu", clearMonitor);
 id("monitor").removeEventListener("mousemove", prevListener1);
 id("monitor").removeEventListener("mouseout", prevListener2);
 id("monitor").addEventListener("mousemove", monitorInfo);
 id("monitor").addEventListener("mouseout", cursorLeave);
 prevListener1 = monitorInfo;
 prevListener2 = cursorLeave;
 window.addEventListener("keydown", keySeek);
 encoder.onmessage = function(event)
  {
  clearTimeout(haltTimeout);
  haltTimeout = setTimeout("previewError()", 2000);
  let received = event.data;
  switch(received.type)
   {
   case "success":
    {
	if(!seek){audioTime = received.endStamp;}
	let roundStamp = Math.round(audioTime);
	if(prevTime != roundStamp)
	 {
	 previewInfo(false, audioTime, audioDuration);
     }
	prevTime = roundStamp;
	let audioBuffer = realTimePlayer.createBuffer(usedChannels, received.sampleLen, sampleRate);
    audioBuffer.copyToChannel(received.audioL, 0);
    if(usedChannels == 2)
     {
	 audioBuffer.copyToChannel(received.audioR, 1);
	 }
    currentBuffer = playBuffer;
	playBuffer = realTimePlayer.createBufferSource();
    playBuffer.buffer = audioBuffer;
    playBuffer.connect(realTimePlayer.destination);
    playBuffer.onended = requestNext;
    if(firstFrame)
     {
	 firstFrame = false;
	 requestNext();
	 playerTime = realTimePlayer.currentTime;
	 }
	playBuffer.start(playerTime);
	playerTime += received.duration;
	sumTime += received.duration;
	sumFrames++;
	sumVal += received.avgBitrate;
	nextReady = true;
	if(sumTime >= monitorRefresh)
	 {
	 sumTime = 0;
	 if(bitrates.length >= 400)
	  {
	  bitrates.shift();
	  }
	 let chunkRate = sumVal / sumFrames;
	 bitrates.push(chunkRate);
	 if(bitrates.length > 1)
	  {
	  let graphPoints = scaleGraph(bitrates);
	  drawGraph(graphPoints.scaled);
	  topVal = graphPoints.lineMax;
	  bottomVal = graphPoints.lineMin;
	  if(Math.abs(topVal - bottomVal) < 1)
	   {
	   topVal++;
	   }
	  id("monCurrent").innerHTML = "Current: " + (chunkRate / 1000).toFixed(2) + "kbps";
	  id("monAverage").innerHTML = "Average: " + graphPoints.average.toFixed(2) + "kbps";
	  if(isCursor)
	   {
	   let b = topVal;
	   let a = (bottomVal - topVal) / 84;
	   let at = a * lastPos + b;
	   id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
	   }
	  }
	 sumVal = 0;
	 sumFrames = 0;
	 }
	}
   break;
   case "stopped":
    {
	endPreview();
	audioBuffer = new Int32Array(received.audio);
	}
   break;
   case "error":
    {
	endPreview();
	audioBuffer = new Int32Array(received.audio);
	viewInfo(false, received.desc, "#ff0000");
	}
   break;
   }
  }
 encoder.onerror = function(event)
  {
  encoder.terminate();
  viewInfo(false, event.message, "#ff0000");
  wasLoaded = false;
  inputFile(false);
  endPreview();
  previewInfo(true);
  fileInfo("No file loaded...", 0, "#777");
  }
 function requestNext()
  {
  if(wasStopped)
   {
   return;
   }
  if(!nextReady)
   {
   if(fragLen < 1)
    {
	fragLen += 0.01 + Math.round(fragLen * 20) / 100;
	}
   console.log("Adjusted to " + fragLen + "s chunk length");
   }
  if(audioTime + fragLen >= audioDuration)
   {
   audioTime = 0;
   }
  configData.values = getEncodingParams();
  encoder.postMessage(configData);
  encoder.postMessage({type: "slice", startFrom: audioTime, fragment: fragLen});
  nextReady = false;
  seek = false;
  }
 function seekForw(event)
  {
  let seekTime = 5;
  if(event.ctrlKey)
   {
   seekTime = 1;
   }
  else if(event.shiftKey)
   {
   seekTime = 30;
   }
  seekBy(seekTime, false);
  }
 function seekRev(event)
  {
  if(event.ctrlKey && event.shiftKey)
   {
   audioTime = 0;
   seek = true;
   return;
   }
  let seekTime = 5;
  if(event.ctrlKey)
   {
   seekTime = 1;
   }
  else if(event.shiftKey)
   {
   seekTime = 30;
   }
  seekBy(seekTime, true);
  }
 function keySeek(event)
  {
  let pressed = event.code;
  let isShift = event.shiftKey;
  if(pressed.startsWith("Arrow") && event.cancelable)
   {
   event.preventDefault();
   }
  switch(pressed)
   {
   case "Space":
    {
	stopRequest();
	}
   break;
   case "ArrowRight":
    {
	seekBy(5, false);
	}
   break;
   case "ArrowLeft":
    {
	if(isShift)
	 {
	 audioTime = 0;
	 seek = true;
	 return;
	 }
	seekBy(5, true);
	}
   break;
   case "ArrowUp":
    {
	isShift ? seekBy(30, false) : seekBy(1, false);
	}
   break;
   case "ArrowDown":
    {
	isShift ? seekBy(30, true) : seekBy(1, true);
	}
   break;
   }
  }
 function seekBy(jump, dir)
  {
  if(dir)
   {
   let newTime = audioTime - jump;
   if(newTime < 0)
    {
    newTime = audioDuration - jump;
    if(newTime < 0)
     {
	 newTime = 0;
	 }
    }
   audioTime = newTime;
   seek = true;
   return;
   }
  let newTime = audioTime + jump;
  if(newTime >= audioDuration)
   {
   newTime = 0;
   }
  audioTime = newTime;
  seek = true;
  }
 function clearMonitor(event)
  {
  if(event.cancelable)
   {
   event.preventDefault();
   }
  let elems = bitrates.length;
  if(elems >= 20)
   {
   bitrates = bitrates.slice(elems - 20, elems);
   }
  }
 function monitorInfo(event)
  {
  isCursor = true;
  let y = event.offsetY - 4;
  if(y < 0){y = 0;}
  else if(y > 84){y = 84;}
  lastPos = y;
  let b = topVal;
  let a = (bottomVal - topVal) / 84;
  let at = a * y + b;
  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
  }
 function cursorLeave()
  {
  isCursor = false;
  id("monCursor").innerHTML = "Cursor: ---";
  }
 function stopRequest()
  {
  encoder.postMessage({type: "stop"});
  wasStopped = true;
  try{playBuffer.stop(); currentBuffer.stop();}catch{}
  }
 function endPreview()
  {
  clearTimeout(haltTimeout);
  try{playBuffer.stop()}catch{}
  id("forw").removeEventListener("mousedown", seekForw);
  id("rev").removeEventListener("mousedown", seekRev);
  id("play").removeEventListener("click", stopRequest);
  id("monitor").removeEventListener("contextmenu", clearMonitor);
  window.removeEventListener("keydown", keySeek);
  busyPreview = false;
  UIforPreview(false);
  }
 }

let timeoutExecuted;

function fileInfo(text, dur, clr, textAft, clrAft)
 {
 clearTimeout(timeoutExecuted);
 id("fileName").style.color = clr;
 id("fileName").innerHTML = text;
 if(id("fileName").clientWidth < id("fileName").scrollWidth)
  {
  for(let i=12; i<text.length; i++)
   {
   id("fileName").innerHTML = text.substr(0, i).trim() + "...";
   if(id("fileName").clientWidth < id("fileName").scrollWidth)
    {
	id("fileName").innerHTML = text.substr(0, i - 1).trim() + "...";
	break;
	}
   }
  }
 if(dur == 0)
  {
  return;
  }
 timeoutExecuted = setTimeout(function()
  {
  id("fileName").style.color = clrAft;
  id("fileName").innerHTML = textAft;
  if(id("fileName").clientWidth < id("fileName").scrollWidth)
   {
   for(let i=12; i<textAft.length; i++)
    {
    id("fileName").innerHTML = textAft.substr(0, i).trim() + "...";
    if(id("fileName").clientWidth < id("fileName").scrollWidth)
     {
	 id("fileName").innerHTML = textAft.substr(0, i - 1).trim() + "...";
	 break;
	 }
    }
   }
  }, dur);
 }

function viewInfo(hide, text, clr)
 {
 if(hide)
  {
  id("resInfo").style.opacity = "0";
  return;
  }
 id("resInfo").style.color = clr;
 id("resInfo").innerHTML = text;
 id("resInfo").style.opacity = "1";
 }
 
function previewInfo(unknown, timeStamp, totalTime)
 {
 if(unknown)
  {
  id("prevInfo").innerHTML = "-:-- / -:--";
  return;
  }
 let time1 = formatTimeSimple(Math.round(timeStamp));
 let time2 = formatTimeSimple(Math.round(totalTime));
 id("prevInfo").innerHTML = time1 + "/" + time2;
 }

function changeUI(busy)
 {
 const buttonIDs = ["loadNew", "downFile", "downPrev", "rev", "play", "forw"];
 clearMonitor();
 if(busy)
  {
  for(let buttID of buttonIDs)
   {
   id(buttID).style.pointerEvents = "none";
   }
  id("enc").style.pointerEvents = "none";
  id("resInfo").style.opacity = "0";
  id("progInfo").style.color = "#fff";
  id("progInfo").innerHTML = "Initializing...";
  return;
  }
 id("progInfo").style.color = "#818181";
 id("progInfo").innerHTML = "Currently idle...";
 for(let buttID of buttonIDs)
  {
  id(buttID).style.pointerEvents = "all";
  }
 if(wasLoaded)
  {
  id("enc").style.pointerEvents = "all";
  }
 id("prBar").value = "0";
 }

function UIforPreview(start)
 {
 const buttonIDs = ["loadNew", "downFile", "downPrev"];
 clearMonitor();
 if(start)
  {
  for(let buttID of buttonIDs)
   {
   id(buttID).style.pointerEvents = "none";
   }
  id("play").setAttribute("class", "prevBtn pauseBtn");
  id("enc").style.pointerEvents = "none";
  id("forw").style.pointerEvents = "all";
  id("rev").style.pointerEvents = "all";
  id("progInfo").style.color = "#fff";
  id("progInfo").innerHTML = "Preview in progress...";
  previewInfo(false, 0, audioDuration);
  return;
  }
 id("progInfo").style.color = "#818181";
 id("progInfo").innerHTML = "Currently idle...";
 id("play").setAttribute("class", "prevBtn playBtn");
 id("loadNew").style.pointerEvents = "all";
 id("forw").style.pointerEvents = "none";
 id("rev").style.pointerEvents = "none";
 if(wasEncoded)
  {
  id("downFile").style.pointerEvents = "all";
  id("downPrev").style.pointerEvents = "all";
  }
 if(wasLoaded)
  {
  id("enc").style.pointerEvents = "all";
  previewInfo(false, 0, audioDuration);
  }
 }

function clearMonitor()
 {
 id("monCurrent").innerHTML = "Current: ---";
 id("monAverage").innerHTML = "Average: ---";
 id("monCursor").innerHTML = "Cursor: ---";
 }

function formatSize(size)
 {
 let suffixes = ["B", "KB", "MB", "GB"];
 let bases = [1, 1024, 1048576, 1073741824];
 let precisions = [0, 2, 3, 4];
 let chosen = 0;
 for(let i=1; i<4; i++)
  {
  if(size >= bases[i])
   {
   chosen++;
   continue;
   }
  break;
  }
 let formatted = (size / bases[chosen]).toFixed(precisions[chosen]) + suffixes[chosen];
 return formatted;
 }

function formatSampling(rate)
 {
 let suffixes = ["Hz", "kHz", "kHz", "kHz"];
 let bases = [1, 1000, 10000, 100000];
 let precisions = [0, 2, 1, 0];
 let chosen = 0;
 for(let i=1; i<4; i++)
  {
  if(rate >= bases[i])
   {
   chosen++;
   continue;
   }
  break;
  }
 if(chosen > 0)
  {
  rate /= 1000;
  }
 let formatted = rate.toFixed(precisions[chosen]) + suffixes[chosen];
 return formatted;
 }

function formatTime(seconds)
 {
 let divide = 3600;
 let suffixes = ["h", "min"];
 let timeString = "";
 let added = false;
 for(let i=0; i<3; i++)
  {
  let single = parseInt(seconds / divide);
  if(single || added || i == 2)
   {
   if(added)
    {
	timeString += single.toString().padStart(2, "0");
	}
   else
    {
	timeString += single;
	}
   i < 2 ? timeString += suffixes[i] + " " : timeString += "s";
   added = true;
   }
  seconds %= divide;
  divide /= 60;
  }
 return timeString;
 }

function formatTimeSimple(seconds)
 {
 let divide = 3600;
 let timeString = "";
 let added = false;
 for(let i=0; i<3; i++)
  {
  let single = parseInt(seconds / divide);
  if(single || added || i == 1)
   {
   if(added)
    {
	timeString += single.toString().padStart(2, "0");
	}
   else
    {
	timeString += single;
	}
   if(i < 2)
    {
	timeString += ":";
	}
   added = true;
   }
  seconds %= divide;
  divide /= 60;
  }
 return timeString;
 }

function cleanBuffers()
 {
 downloads(false);
 encodedBuffer = new Uint8Array(0);
 decodedBuffer = new Uint8Array(0);
 wasEncoded = false;
 }
 
function downloads(present)
 {
 if(present)
  {
  id("downFile").style.opacity = "1";
  id("downPrev").style.opacity = "1";
  id("downFile").style.pointerEvents = "all";
  id("downPrev").style.pointerEvents = "all";
  return;
  }
 id("downFile").style.pointerEvents = "none";
 id("downPrev").style.pointerEvents = "none";
 id("downFile").style.opacity = "0.7";
 id("downPrev").style.opacity = "0.7";
 }
 
function inputFile(present)
 {
 if(present)
  {
  id("play").style.pointerEvents = "all";
  id("enc").style.pointerEvents = "all";
  id("enc").style.opacity = "1";
  return;
  }
 id("play").style.pointerEvents = "none";
 id("enc").style.pointerEvents = "none";
 id("enc").style.opacity = "0.7";
 }
 
function fileLoad(start)
 {
 busyLoading = start;
 if(start)
  {
  id("loadNew").style.pointerEvents = "none";
  return;
  }
 id("loadNew").style.pointerEvents = "all";
 }

function getPreset(which, update)
 {
 switch(which)
  {
  case 0:
   {
   let set = parseInt(id("dnRange").value || 96);
   if(update){id("dnRangeVal").innerHTML = set + "dB";}
   return set;
   }
  case 1:
   {
   let set = parseInt(id("ctFreq").value || 146);
   set = (set + 30) * 100;
   if(update){id("ctFreqVal").innerHTML = (set / 1000).toFixed(1) + "kHz";}
   return set;
   }
  case 2:
   {
   let set = parseInt(id("upLim").value || 54);
   set *= set * 0.2474747 + 0.50505;
   set = Math.round(set);
   if(update){id("upLimVal").innerHTML = set;}
   return set;
   }
  case 3:
   {
   let set = parseInt(id("loLim").value || 54);
   set *= set * 0.2474747 + 0.50505;
   set = Math.round(set);
   if(update){id("loLimVal").innerHTML = set;}
   return set;
   }
  case 4:
   {
   let set = parseInt(id("impFreq").value || 80) * 10;
   if(update)
    {
	if(set >= 1000)
	 {
	 id("impFreqVal").innerHTML = (set / 1000).toFixed(2) + "kHz";
	 }
	else
	 {
	 id("impFreqVal").innerHTML = set + "Hz"
	 }
	}
   return set;
   }
  case 5:
   {
   let set = parseFloat(id("qual").value || 15);
   if(update){id("qualInfo").innerHTML = "Quality: " + set.toFixed(2);}
   return set;
   }
  }
 return 0;
 }

function rawVal(which)
 {
 const sliders = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 return parseFloat(id(sliders[which]).value || 0);
 }

function fieldVal(which)
 {
 if(which == 3)
  {
  return id("adaptAllocApply").checked + 0;
  }
 const fields = ["transientField", "subbandField", "keyframeField"];
 return parseInt(id(fields[which]).value || 0);
 }

function isBorder(which, dir)
 {
 const sliders = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 const upper = parseInt(id(sliders[which]).max);
 const lower = parseInt(id(sliders[which]).min);
 const set = parseFloat(id(sliders[which]).value);
 return (!dir && set >= upper) || (dir && set <= lower);
 }
 
function checkAdvanced()
 {
 id("advanced").checked ? id("advBox").style.height = "400px" : id("advBox").style.height = "36px";
 }

function rescale()
 {
 let UIscale = 1;
 window.addEventListener("resize", adjustSize);
 function adjustSize()
  {
  let w = window.innerWidth;
  let h = window.innerHeight;
  let x_ovf = w / 1200;
  let y_ovf = h / 880;
  let scaleBy = Math.min(x_ovf, y_ovf);
  if(scaleBy > 1)
   {
   scaleBy = 1;
   }
  let topMarg = 355 * scaleBy - 355;
  if(topMarg < -100)
   {
   topMarg = -100;
   }
  document.body.style.transform = "scale(" + scaleBy + ")";
  document.body.style.marginTop = topMarg + "px";
  }
 adjustSize();
 }

function normalArray(from)
 {
 let sliced = [];
 for(let i=0; i<from.length; i++)
  {
  sliced.push(from[i]);
  }
 return sliced;
 }
 
function getFrDbg(which, channel)
 {
 let offset = which * 512 * audioChannels + channel;
 let sliced = new Array(1024);
 let at = offset;
 for(let i=0; i<1024; i++)
  {
  sliced[i] = audioBuffer[at];
  at += audioChannels;
  }
 return sliced;
 }


</script>
</head>
<body onload="run()" style="text-align:center; background:radial-gradient(circle at 50% 0%, #363636, #050505); background-color:#141414; background-image:url(graphics/speakers.png); background-repeat:no-repeat; background-size:cover; margin:0; height:100vh; overflow:hidden; transform:scale(1); white-space:nowrap">
<div style="text-align:center; margin:0; position:relative; width:100vw">
<h1>DAC - Dynamic Audio Codec</h1>
<div style="text-align:center; position:relative; display:inline-block; margin-top:1%">
<div class="contentBox" id="loaderBox" style="width:700px; height:40px; margin-top:0px; padding-top:9px; padding-left:7px; padding-right:10px">
<span style="float:left; cursor:default">INPUT FILE:</span>
<span id="fileName" style="color:#777; margin-left:7px; float:left; cursor:default; max-width:410px; white-space:nowrap">No file loaded...</span>
<input type="button" id="loadNew" class="btn" value="Load audio" style="width:130px; float:right"/>
<input type="file" accept=".wav,.dac,.mp3,.aac,.ogg,.flac" id="sound" style="display:none"/>
<a href="" download="" id="dacFile" style="display:none"></a>
<a href="" download="" id="wavFile" style="display:none"></a>
</div>
<div class="contentBox" id="qualityBox" style="width:700px; height:55px; display:block; margin-top:3%; padding-top:9px; padding-left:7px; padding-right:10px">
<div style="text-align:center; position:relative; display:inline-block">
<span id="qualInfo" style="font-size:19px; display:block; cursor:default; margin-bottom:3px">Quality: 15.00</span>
<input type="range" class="horSlider" id="qual" min="0" max="100" step="0.05" value="15" style="width:420px; height:20px; outline:none; cursor:pointer; display:inline-block"/>
</div>
<input type="button" id="enc" class="btn" value="Compress" style="width:130px; float:right; margin-top:7px; pointer-events:none; opacity:0.7"/>
</div>
<div class="contentBox" id="infoBox" style="width:707px; height:90px; display:block; margin-top:3%; padding-right:10px">
<div style="text-align:center; position:relative; display:inline-block; vertical-align:top; margin-top:10px">
<span id="progInfo" style="font-size:14px; display:block; cursor:default; color:#818181">Currently idle...</span>
<progress id="prBar" max="100" value="0" style="outline:none; display:block; margin-top:10px; margin-bottom:8px; cursor:default"></progress>
<span id="resInfo" style="font-size:14px; display:block; cursor:default; opacity:0; transition:0.3s; max-width:400px; white-space:nowrap">Encoding results...</span>
</div>
<div style="text-align:center; position:relative; display:inline-block; vertical-align:top; float:right; margin-right:15px">
<span style="font-size:17px; display:block; cursor:default; margin-top:8px">Downloads:</span>
<input type="button" id="downFile" class="btn" value="DAC file" style="width:95px; margin-top:8px; display:inline-block; vertical-align:top; pointer-events:none; opacity:0.7"/>
<input type="button" id="downPrev" class="btn" value="Wave file" style="width:95px; margin-top:8px; display:inline-block; vertical-align:top; pointer-events:none; opacity:0.7"/>
</div>
</div>
<div class="contentBox" id="advBox" style="width:700px; height:36px; display:block; margin-top:3%; padding-left:7px; padding-right:10px; transition:0.4s ease-in-out height">
<span style="font-size:15px; display:inline-block; cursor:default; margin-top:8px; margin-left:10px; float:left">Real-time preview:</span>
<button id="rev" class="prevBtn revBtn" style="margin-left:10px; pointer-events:none"></button>
<button id="play" class="prevBtn playBtn" style="margin-left:30px; margin-top:10px; pointer-events:none"></button>
<button id="forw" class="prevBtn ffBtn" style="margin-left:25px; pointer-events:none"></button>
<span id="prevInfo" style="font-size:15px; margin-top:9px; margin-left:20px; width:0px; white-space:nowrap; display:inline-block; float:left; cursor:default; color:#fff">-:-- / -:--</span>
<span style="font-size:18px; margin-top:7px; margin-left:185px; display:inline-block; vertical-align:top; cursor:default">Advanced panel</span>
<label class="slider" style="margin-top:6px; margin-left:4px">
<input type="checkbox" id="advanced" class="hide"/>
<span class="switch"></span>
</label>
<div style="position:relative; display:block; float:left; vertical-align:top; margin-left:275px; white-space:nowrap">
<div class="sliderBox" style="margin-left:-322px">
<span class="sliderDesc">Dynamic Range</span>
<input type="checkbox" id="apply0" class="applyBox"/>
<span id="dnRangeVal" class="currVal">96dB</span>
<input type="range" class="vertSlider" id="dnRange" min="48" max="120" step="1" value="96"/>
<span class="topVal">120dB</span>
<span class="minVal">48dB</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:-205px">
<span class="sliderDesc" style="margin-left:57px">Cutoff Frequency</span>
<input type="checkbox" id="apply1" class="applyBox" style="margin-left:68px"/>
<span id="ctFreqVal" class="currVal" style="margin-left:86px">17.6kHz</span>
<input type="range" class="vertSlider" id="ctFreq" min="0" max="210" step="1" value="146"/>
<span class="topVal" style="margin-left:60px">24kHz</span>
<span class="minVal" style="margin-left:65px">3kHz</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:-88px">
<span class="sliderDesc" style="margin-left:62px">Upper Bit Limit</span>
<input type="checkbox" id="apply2" class="applyBox"/>
<span id="upLimVal" class="currVal">749</span>
<input type="range" class="vertSlider" id="upLim" min="2" max="200" step="1" value="54"/>
<span class="topVal" style="margin-left:60px">10000</span>
<span class="minVal" style="margin-left:82px">2</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:29px">
<span class="sliderDesc" style="margin-left:62px">Lower Bit Limit</span>
<input type="checkbox" id="apply3" class="applyBox"/>
<span id="loLimVal" class="currVal">30</span>
<input type="range" class="vertSlider" id="loLim" min="2" max="200" step="1" value="10"/>
<span class="topVal" style="margin-left:60px">10000</span>
<span class="minVal" style="margin-left:82px">2</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:117px">
<span class="sliderDesc" style="margin-left:55px; font-size:10.5px">Lower Frequencies</span>
<input type="checkbox" id="apply4" class="applyBox"/>
<span id="impFreqVal" class="currVal">800Hz</span>
<input type="range" class="vertSlider" id="impFreq" min="0" max="200" step="1" value="80"/>
<span class="topVal" style="margin-left:66px">2kHz</span>
<span class="minVal" style="margin-left:71px">0Hz</span>
<div class="sliderBg"></div>
</div>
<div style="position:relative; white-space:normal; margin-left:-7px; display:inline-block; width:300px">
<span class="selectDesc" style="margin-left:157px; margin-top:20px">Transient detect<br>sensitivity:</span>
<select id="transientField" style="width:90px; margin-top:6px; margin-left:160px">
<option value="0">None</option>
<option value="1">Low</option>
<option value="2" selected>Moderate</option>
<option value="3">Extreme</option>
</select>
<span class="selectDesc" style="margin-left:157px; margin-top:9px">Group size:</span>
<select id="subbandField" style="width:90px; margin-top:2px; margin-left:160px">
<option value="0">4</option>
<option value="1" selected>8</option>
<option value="2">16</option>
<option value="3">32</option>
</select>
<span class="selectDesc" style="margin-left:157px; margin-top:8px">Keyframe interval:</span>
<select id="keyframeField" style="width:90px; margin-top:2px; margin-left:160px">
<option value="0">0.5s</option>
<option value="1">1s</option>
<option value="2" selected>2s</option>
<option value="3">5s</option>
<option value="4">10s</option>
<option value="5">30s</option>
</select>
<span class="selectDesc" style="margin-left:162px; margin-top:8px">Adaptive alloc</span>
<input type="checkbox" id="adaptAllocApply" class="applyBox" style="margin-left:-2px; position:relative; display:inline-block; margin-top:10px" checked/>
</div>
</div>
<div style="position:relative; display:inline-block; text-align:center">
<span style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:8px">Bitrate Monitor</span>
<canvas id="monitor" width="2000" height="250" style="width:660px; height:85px; background-color:#373737; border:2px solid white; border-radius:2px; margin-top:-1px; display:block; padding:4px; cursor:crosshair"></canvas>
<span id="monCurrent" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Current: ---</span>
<span id="monAverage" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Average: ---</span>
<span id="monCursor" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Cursor: ---</span>
</div>
</div>
</div>
<div class="contentBox" id="metaBox" style="width:300px; height:385px; margin-top:1%; margin-left:20px; padding:10px">
<input id="meta0" type="text" placeholder="Title" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta1" type="text" placeholder="Artist" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta2" type="text" placeholder="Album" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta3" type="text" placeholder="Genre" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta4" type="text" placeholder="Year" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta5" type="text" placeholder="Track" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<span style="font-size:16px; margin-top:20px; display:inline-block; vertical-align:top; cursor:default">Load metadata from file</span>
<label class="slider" style="margin-top:17px; margin-left:4px">
<input type="checkbox" id="autoLoad" class="hide" checked/>
<span class="switch"></span>
</label>
<span style="font-size:16px; margin-top:17px; margin-left:53px; display:inline-block; vertical-align:top; cursor:default">Include metadata</span>
<label class="slider" style="margin-top:14px; margin-left:4px">
<input type="checkbox" id="inclMeta" class="hide" checked/>
<span class="switch"></span>
</label>
</div>
</div>
</body>
</html>