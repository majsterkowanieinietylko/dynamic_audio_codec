<!--
    DAC - Dynamic Audio Codec, a lossy audio codec written by MINT: https://www.youtube.com/@__MINT_

    This is a single-file version of DAC with no dependencies on auxiliary files.

    Offers compression better than MP3 while being less computationally heavy. DAC comes as a complete
    audio encoding / decoding browser environment and allows to tune some advanced encoding parameters
    to maximize performance. Supports wide range of bitrates, sample rates and audio channels. DAC is
    fully VBR and doesn't have any CBR mode, so it is not intended for hitting a target bitrate. Audio
    quality setting is provided by the user instead.

    eDAC - Enhanced Dynamic Audio Codec offering quality much better than DAC is currently in development.
    Stay tuned!

    And keep in mind, that DAC software comes with absolutely no warranty! If you're hacking it and
    it blows up your ears, I am not responsible for that.
-->

<!DOCTYPE html>
<html lang="en-EN">
<head>
<meta charset="UTF-8">
<title>DAC</title>
<link rel="shortcut icon" href="graphics/note.png">
<script type="text/javascript">

const lookupString = `

const regionSizesTonal = [6, 5, 2, 1];
const regionSizesNoise = [7, 5, 3, 1];
const noiseFloors = [0, 156.25, 40000, 10240000];
const tonalVerify = [[-2, 2], [-3, -2, 2, 3], [-6, -5, -4, -3, -2, 2, 3, 4, 5, 6]];
const verifySizes = [2, 4, 10];
const tops = [0, 255, 32767, 8388607];
const bottoms = [0, 0, -32768, -8388608];
const normalizeFactors = [1, 128, 32768, 8388608];

function SMRreject(bitLimit)
 {
 if(bitLimit >= 20)
  {
  return 1;
  }
 return -0.7 * bitLimit + 15;
 }

function dynamicLimit(bitLimit)
 {
 return dynamicRange * ((7 * bitLimit + 500) / 1200);
 }

function cutoff(bitLimit)
 {
 if(bitLimit >= 5)
  {
  return -0.886426 * bitLimit * bitLimit + 177.2853186 * bitLimit + 15135.74;
  }
 return 3000 + bitLimit * 2600;
 }

function allowedError(bitLimit, subbandFreq)
 {
 if(bitLimit == 100)
  {
  return 0.005;
  }
 let errorFactor = 10 / (bitLimit + 9.2) - 0.08;
 subbandFreq /= 1000;
 let frqFactor = 0.046875 * subbandFreq * subbandFreq + 3;
 return errorFactor * frqFactor + 0.05;
 }
 
function shrinkBudget(bitLimit)
 {
 if(bitLimit >= 10)
  {
  return 1;
  }
 return -(21 / (bitLimit - 20.7)) - 0.96;
 }

function reqBits(dB)
 {
 if(dB <= 0)
  {
  return 0;
  }
 let needed = Math.ceil(dB / 6.020599913279624) + 1;
 if(needed > 16)
  {
  needed = 16;
  }
 return needed;
 }

function Bark(f)
 {
 let result = (26.81 * f) / (1960 + f) - 0.53;
 return result < 0 ? 0 : result;
 }
 
function Freq(bark)
 {
 let result = (-1960 * bark - 1038.8) / (bark - 26.28);
 return result < 0 ? 0 : result;
 }

function FMDCT(data)
 {
 let real = new Array(256);
 let imag = new Array(256);
 let result = new Array(512);
 let at = 0;
 for(let i=0; i<1024; i++)
  {
  data[i] *= sineWindow[i];
  }
 for(let i=0; i<256; i+=2)
  {
  let r0 = data[767 - i] + data[768 + i];
  let i0 = data[256 + i] - data[255 - i];
  let c = cosines[at];
  let s = sines[at];
  let mirrorIndex = mirrored[at++];
  real[mirrorIndex] = r0 * c + i0 * s;
  imag[mirrorIndex] = i0 * c - r0 * s;
  }
 for(let i=256; i<512; i+=2)
  {
  let r0 = data[767 - i] - data[i - 256];
  let i0 = data[256 + i] + data[1279 - i];
  let c = cosines[at];
  let s = sines[at];
  let mirrorIndex = mirrored[at++];
  real[mirrorIndex] = r0 * c + i0 * s;
  imag[mirrorIndex] = i0 * c - r0 * s;
  }
 let inc = 256;
 let step = 1;
 let width;
 for(let stage=0; stage<8; stage++)
  {
  let twiddleAt = 0;
  inc >>= 1;
  width = step;
  step <<= 1;
  for(let i=0; i<width; i++)
   {
   let WnReal = twiddleReal[twiddleAt];
   let WnImag = twiddleImag[twiddleAt];
   twiddleAt += inc;
   for(let j=i; j<256; j+=step)
    {
	let offset = j + width;
	let topReal = real[j];
	let topImag = imag[j];
	let bottomReal = real[offset];
	let bottomImag = imag[offset];
	let tmpReal;
	let tmpImag;
	if(i)
	 {
	 tmpReal = (bottomReal * WnReal) - (bottomImag * WnImag);
	 tmpImag = (bottomReal * WnImag) + (bottomImag * WnReal);
	 }
	else
	 {
	 tmpReal = bottomReal;
	 tmpImag = bottomImag;
	 }
	real[offset] = topReal - tmpReal;
	imag[offset] = topImag - tmpImag;
	real[j] = topReal + tmpReal;
	imag[j] = topImag + tmpImag;
	}
   }
  }
 at = 0;
 for(let i=0; i<512; i+=2)
  {
  let r0 = real[at];
  let i0 = imag[at];
  let c = cosines[at];
  let s = sines[at++];
  result[i] = -r0 * c - i0 * s;
  result[511 - i] = -r0 * s + i0 * c;
  }
 return result;
 }

function FIMDCT(data, last)
 {
 let real = new Array(256);
 let imag = new Array(256);
 let result = new Array(1024);
 let at = 0;
 let mirrorAt = 0;
 for(let i=0; i<512; i+=2)
  {
  let imagIndex = 511 - i;
  let realIndex = i;
  let c = cosines[at];
  let s = sines[at];
  let mirrorIndex = mirrored[at++];
  let r0 = realIndex < last ? data[realIndex] : 0;
  let i0 = imagIndex < last ? data[imagIndex] : 0;
  real[mirrorIndex] = -i0 * s - r0 * c;
  imag[mirrorIndex] = -i0 * c + r0 * s;
  }
 let inc = 256;
 let step = 1;
 let width;
 for(let stage=0; stage<8; stage++)
  {
  let twiddleAt = 0;
  inc >>= 1;
  width = step;
  step <<= 1;
  for(let i=0; i<width; i++)
   {
   let WnReal = twiddleReal[twiddleAt];
   let WnImag = twiddleImag[twiddleAt];
   twiddleAt += inc;
   for(let j=i; j<256; j+=step)
    {
	let offset = j + width;
	let topReal = real[j];
	let topImag = imag[j];
	let bottomReal = real[offset];
	let bottomImag = imag[offset];
	let tmpReal;
	let tmpImag;
	if(i)
	 {
	 tmpReal = (bottomReal * WnReal) - (bottomImag * WnImag);
	 tmpImag = (bottomReal * WnImag) + (bottomImag * WnReal);
	 }
	else
	 {
	 tmpReal = bottomReal;
	 tmpImag = bottomImag;
	 }
	real[offset] = topReal - tmpReal;
	imag[offset] = topImag - tmpImag;
	real[j] = topReal + tmpReal;
	imag[j] = topImag + tmpImag;
	}
   }
  }
 at = 0;
 for(let i=0; i<256; i+=2)
  {
  let r0 = real[at];
  let i0 = imag[at];
  let c = cosines[at];
  let s = sines[at++];
  let r1 = r0 * c + i0 * s;
  let i1 = r0 * s - i0 * c;
  result[767 - i] = r1;
  result[768 + i] = r1;
  result[256 + i] = i1;
  result[255 - i] = -i1;
  }
 for(let i=256; i<512; i+=2)
  {
  let r0 = real[at];
  let i0 = imag[at];
  let c = cosines[at];
  let s = sines[at++];
  let r1 = r0 * c + i0 * s;
  let i1 = r0 * s - i0 * c;
  result[767 - i] = r1;
  result[i - 256] = -r1;
  result[256 + i] = i1;
  result[1279 - i] = i1;
  }
 for(let i=0; i<1024; i++)
  {
  result[i] *= sineWindow[i];
  }
 return result;
 }

const scaleFactors = [20000.000000000000000, 12500.000000000000000, 7812.500000000000000, 4882.812500000000000, 3051.757812500000000, 1907.348632812500000, 1192.092895507812500, 
745.058059692382813, 465.661287307739258, 291.038304567337036, 181.898940354585648, 113.686837721616030, 71.054273576010019, 44.408920985006262, 
27.755575615628914, 17.347234759768071, 10.842021724855044, 6.776263578034403, 4.235164736271502, 2.646977960169688, 1.654361225106055, 
1.033975765691284, 0.646234853557053, 0.403896783473158, 0.252435489670724, 0.157772181044202, 0.098607613152626, 0.061629758220392, 
0.038518598887745, 0.024074124304840, 0.015046327690525, 0.009403954806578, 0.005877471754111, 0.003673419846320, 0.002295887403950, 
0.001434929627469, 0.000896831017168, 0.000560519385730, 0.000350324616081, 0.000218952885051, 0.000136845553157, 0.000085528470723, 
0.000053455294202, 0.000033409558876, 0.000020880974298, 0.000013050608936, 0.000008156630585, 0.000005097894116, 0.000003186183822, 
0.000001991364889, 0.000001244603056, 0.000000777876910, 0.000000486173069, 0.000000303858168, 0.000000189911355, 0.000000118694597, 
0.000000074184123, 0.000000046365077, 0.000000028978173, 0.000000018111358, 0.000000011319599, 0.000000007074749, 0.000000004421718, 
0.000000002763574];

const scaleFactorsInv = [0.0000500000, 0.0000800000, 0.0001280000, 0.0002048000, 0.0003276800, 0.0005242880, 0.0008388608, 
0.0013421773, 0.0021474836, 0.0034359738, 0.0054975581, 0.0087960930, 0.0140737488, 0.0225179981, 
0.0360287970, 0.0576460752, 0.0922337204, 0.1475739526, 0.2361183241, 0.3777893186, 0.6044629098, 
0.9671406557, 1.5474250491, 2.4758800786, 3.9614081257, 6.3382530011, 10.1412048018, 16.2259276829, 
25.9614842927, 41.5383748683, 66.4613997892, 106.3382396628, 170.1411834605, 272.2258935367, 435.5614296588, 
696.8982874539, 1115.0372599264, 1784.0596158822, 2854.4953854136, 4567.1926166539, 7307.5081866396, 11692.0130986404, 
18707.2209577809, 29931.5535326735, 47890.4856511308, 76624.7770432771, 122599.6432692434, 196159.4292163600, 313855.0867954285, 
502168.1388096423, 803469.0218533418, 1285550.4349653469, 2056880.6948868653, 3291009.1131728273, 5265614.5810765233, 8424983.3208498955, 
13479973.3360735439, 21567957.2795705684, 34508731.7961694822, 55213971.2549439967, 88342352.0568175614, 141347770.7831048071, 226156439.6463094056, 
361850270.7001875043];

const thresholds = [35.000, 29.373, 20.644, 13.596, 10.495, 8.794, 7.646, 6.767, 6.073, 5.559, 5.120, 4.738, 4.423, 4.142, 3.882, 3.652, 
3.435, 3.227, 3.030, 2.841, 2.657, 2.473, 2.288, 2.102, 1.915, 1.720, 1.518, 1.314, 1.097, 0.870, 0.634, 0.392, 
0.141, -0.128, -0.404, -0.687, -0.977, -1.275, -1.580, -1.889, -2.200, -2.514, -2.819, -3.116, -3.404, -3.678, -3.933, -4.168, 
-4.380, -4.557, -4.706, -4.827, -4.918, -4.965, -4.977, -4.952, -4.893, -4.808, -4.684, -4.528, -4.346, -4.142, -3.912, -3.665, 
-3.407, -3.140, -2.862, -2.580, -2.297, -2.016, -1.748, -1.480, -1.221, -0.973, -0.725, -0.501, -0.289, -0.077, 0.105, 0.282, 
0.459, 0.604, 0.747, 0.890, 1.002, 1.115, 1.227, 1.318, 1.409, 1.500, 1.575, 1.648, 1.721, 1.784, 1.842, 1.901, 
1.958, 2.012, 2.067, 2.120, 2.171, 2.221, 2.271, 2.320, 2.370, 2.419, 2.468, 2.519, 2.570, 2.621, 2.673, 2.726, 
2.778, 2.832, 2.889, 2.946, 3.003, 3.060, 3.119, 3.177, 3.236, 3.297, 3.359, 3.422, 3.484, 3.548, 3.612, 3.676, 
3.741, 3.811, 3.882, 3.952, 4.023, 4.096, 4.170, 4.243, 4.317, 4.395, 4.473, 4.550, 4.628, 4.709, 4.791, 4.872, 
4.954, 5.039, 5.126, 5.212, 5.299, 5.388, 5.481, 5.574, 5.666, 5.759, 5.851, 5.944, 6.037, 6.129, 6.230, 6.333, 
6.437, 6.540, 6.643, 6.746, 6.850, 6.953, 7.056, 7.168, 7.281, 7.395, 7.508, 7.621, 7.735, 7.848, 7.961, 8.075, 
8.196, 8.321, 8.445, 8.569, 8.693, 8.818, 8.942, 9.066, 9.190, 9.321, 9.458, 9.595, 9.733, 9.870, 10.007, 10.144, 
10.281, 10.418, 10.557, 10.707, 10.858, 11.009, 11.159, 11.310, 11.461, 11.611, 11.762, 11.913, 12.071, 12.235, 12.399, 12.563, 
12.727, 12.891, 13.055, 13.219, 13.383, 13.547, 13.724, 13.902, 14.080, 14.258, 14.436, 14.614, 14.792, 14.970, 15.148, 15.328, 
15.524, 15.720, 15.916, 16.111, 16.307, 16.503, 16.699, 16.894, 17.090, 17.291, 17.504, 17.717, 17.929, 18.142, 18.355, 18.568, 
18.781, 18.994, 19.207, 19.427, 19.659, 19.890, 20.122, 20.354, 20.585, 20.817, 21.049, 21.280, 21.512, 21.752, 22.002, 22.253, 
22.503, 22.753, 23.004, 23.254, 23.505, 23.755, 24.006, 24.266, 24.538, 24.811, 25.084, 25.357, 25.630, 25.903, 26.176, 26.449, 
26.722, 27.003, 27.295, 27.587, 27.879, 28.171, 28.463, 28.755, 29.047, 29.339, 29.631, 29.930, 30.247, 30.564, 30.881, 31.197, 
31.514, 31.831, 32.148, 32.465, 32.781, 33.103, 33.446, 33.789, 34.131, 34.474, 34.817, 35.160, 35.503, 35.845, 36.188, 36.533, 
36.902, 37.272, 37.642, 38.012, 38.381, 38.751, 39.121, 39.491, 39.860, 40.230, 40.626, 41.023, 41.420, 41.817, 42.213, 42.610, 
43.007, 43.404, 43.800, 44.197, 44.624, 45.058, 45.491, 45.924, 46.357, 46.790, 47.223, 47.656, 48.089, 48.522, 50.000, 55.000];

const sineWindow = [0.001533980186285, 0.004601926120449, 0.007669828739531, 0.010737659167264, 0.013805388528060, 0.016872987947282, 0.019940428551514, 
0.023007681468839, 0.026074717829104, 0.029141508764194, 0.032208025408305, 0.035274238898214, 0.038340120373553, 0.041405640977077, 
0.044470771854939, 0.047535484156959, 0.050599749036899, 0.053663537652731, 0.056726821166908, 0.059789570746640, 0.062851757564161, 
0.065913352797004, 0.068974327628267, 0.072034653246889, 0.075094300847921, 0.078153241632794, 0.081211446809592, 0.084268887593324, 
0.087325535206192, 0.090381360877865, 0.093436335845748, 0.096490431355253, 0.099543618660069, 0.102595869022436, 0.105647153713411, 
0.108697444013139, 0.111746711211127, 0.114794926606510, 0.117842061508325, 0.120888087235777, 0.123932975118512, 0.126976696496886, 
0.130019222722233, 0.133060525157139, 0.136100575175706, 0.139139344163826, 0.142176803519448, 0.145212924652847, 0.148247678986896, 
0.151281037957330, 0.154312973013020, 0.157343455616238, 0.160372457242928, 0.163399949382973, 0.166425903540464, 0.169450291233968, 
0.172473083996796, 0.175494253377271, 0.178513770938998, 0.181531608261125, 0.184547736938620, 0.187562128582530, 0.190574754820253, 
0.193585587295804, 0.196594597670080, 0.199601757621131, 0.202607038844421, 0.205610413053099, 0.208611851978263, 0.211611327369228, 
0.214608810993787, 0.217604274638484, 0.220597690108874, 0.223589029229790, 0.226578263845610, 0.229565365820519, 0.232550307038775, 
0.235533059404975, 0.238513594844318, 0.241491885302869, 0.244467902747824, 0.247441619167773, 0.250413006572965, 0.253382036995570, 
0.256348682489943, 0.259312915132886, 0.262274707023914, 0.265234030285512, 0.268190857063403, 0.271145159526808, 0.274096909868706, 
0.277046080306100, 0.279992643080273, 0.282936570457055, 0.285877834727081, 0.288816408206049, 0.291752263234989, 0.294685372180514, 
0.297615707435086, 0.300543241417273, 0.303467946572011, 0.306389795370861, 0.309308760312269, 0.312224813921825, 0.315137928752522, 
0.318048077385015, 0.320955232427875, 0.323859366517853, 0.326760452320132, 0.329658462528587, 0.332553369866044, 0.335445147084532, 
0.338333766965541, 0.341219202320282, 0.344101425989939, 0.346980410845924, 0.349856129790135, 0.352728555755211, 0.355597661704784, 
0.358463420633737, 0.361325805568454, 0.364184789567080, 0.367040345719767, 0.369892447148934, 0.372741067009516, 0.375586178489217, 
0.378427754808766, 0.381265769222162, 0.384100195016935, 0.386931005514389, 0.389758174069856, 0.392581674072951, 0.395401478947816, 
0.398217562153374, 0.401029897183576, 0.403838457567654, 0.406643216870369, 0.409444148692258, 0.412241226669883, 0.415034424476082, 
0.417823715820212, 0.420609074448403, 0.423390474143796, 0.426167888726800, 0.428941292055329, 0.431710658025057, 0.434475960569656, 
0.437237173661044, 0.439994271309633, 0.442747227564570, 0.445496016513982, 0.448240612285220, 0.450980989045104, 0.453717121000164, 
0.456448982396884, 0.459176547521944, 0.461899790702463, 0.464618686306238, 0.467333208741988, 0.470043332459596, 0.472749031950343, 
0.475450281747156, 0.478147056424843, 0.480839330600334, 0.483527078932919, 0.486210276124486, 0.488888896919763, 0.491562916106550, 
0.494232308515960, 0.496897049022654, 0.499557112545082, 0.502212474045711, 0.504863108531268, 0.507508991052971, 0.510150096706767, 
0.512786400633563, 0.515417878019463, 0.518044504095999, 0.520666254140367, 0.523283103475656, 0.525895027471085, 0.528502001542228, 
0.531104001151255, 0.533701001807153, 0.536292979065963, 0.538879908531008, 0.541461765853123, 0.544038526730884, 0.546610166910835, 
0.549176662187720, 0.551737988404707, 0.554294121453620, 0.556845037275160, 0.559390711859136, 0.561931121244689, 0.564466241520519, 
0.566996048825109, 0.569520519346947, 0.572039629324757, 0.574553355047716, 0.577061672855679, 0.579564559139406, 0.582061990340775, 
0.584553942953015, 0.587040393520918, 0.589521318641064, 0.591996694962041, 0.594466499184664, 0.596930708062197, 0.599389298400565, 
0.601842247058580, 0.604289530948156, 0.606731127034524, 0.609167012336453, 0.611597163926462, 0.614021558931038, 0.616440174530854, 
0.618852987960976, 0.621259976511088, 0.623661117525695, 0.626056388404344, 0.628445766601833, 0.630829229628424, 0.633206755050057, 
0.635578320488556, 0.637943903621844, 0.640303482184152, 0.642657033966227, 0.645004536815544, 0.647345968636512, 0.649681307390683, 
0.652010531096960, 0.654333617831800, 0.656650545729429, 0.658961292982037, 0.661265837839992, 0.663564158612040, 0.665856233665510, 
0.668142041426518, 0.670421560380173, 0.672694769070773, 0.674961646102012, 0.677222170137180, 0.679476319899365, 0.681724074171650, 
0.683965411797315, 0.686200311680039, 0.688428752784090, 0.690650714134535, 0.692866174817425, 0.695075113980001, 0.697277510830887, 
0.699473344640284, 0.701662594740168, 0.703845240524485, 0.706021261449340, 0.708190637033195, 0.710353346857062, 0.712509370564692, 
0.714658687862769, 0.716801278521100, 0.718937122372804, 0.721066199314508, 0.723188489306527, 0.725303972373061, 0.727412628602376, 
0.729514438146997, 0.731609381223893, 0.733697438114660, 0.735778589165713, 0.737852814788466, 0.739920095459516, 0.741980411720831, 
0.744033744179929, 0.746080073510064, 0.748119380450403, 0.750151645806215, 0.752176850449043, 0.754194975316889, 0.756206001414395, 
0.758209909813015, 0.760206681651202, 0.762196298134579, 0.764178740536117, 0.766153990196313, 0.768122028523365, 0.770082836993348, 
0.772036397150384, 0.773982690606823, 0.775921699043408, 0.777853404209453, 0.779777787923014, 0.781694832071059, 0.783604518609638, 
0.785506829564054, 0.787401747029031, 0.789289253168886, 0.791169330217690, 0.793041960479444, 0.794907126328237, 0.796764810208419, 
0.798614994634761, 0.800457662192623, 0.802292795538116, 0.804120377398266, 0.805940390571176, 0.807752817926190, 0.809557642404051, 
0.811354847017064, 0.813144414849254, 0.814926329056527, 0.816700572866828, 0.818467129580299, 0.820225982569435, 0.821977115279242, 
0.823720511227391, 0.825456154004377, 0.827184027273669, 0.828904114771865, 0.830616400308846, 0.832320867767930, 0.834017501106018, 
0.835706284353753, 0.837387201615662, 0.839060237070313, 0.840725374970458, 0.842382599643186, 0.844031895490066, 0.845673246987299, 
0.847306638685858, 0.848932055211640, 0.850549481265603, 0.852158901623920, 0.853760301138111, 0.855353664735196, 0.856938977417829, 
0.858516224264443, 0.860085390429390, 0.861646461143081, 0.863199421712124, 0.864744257519462, 0.866280954024513, 0.867809496763303, 
0.869329871348607, 0.870842063470079, 0.872346058894392, 0.873841843465367, 0.875329403104111, 0.876808723809146, 0.878279791656541, 
0.879742592800047, 0.881197113471222, 0.882643339979563, 0.884081258712635, 0.885510856136200, 0.886932118794342, 0.888345033309596, 
0.889749586383073, 0.891145764794583, 0.892533555402765, 0.893912945145203, 0.895283921038558, 0.896646470178680, 0.898000579740740, 
0.899346236979341, 0.900683429228647, 0.902012143902493, 0.903332368494512, 0.904644090578246, 0.905947297807268, 0.907241977915296, 
0.908528118716306, 0.909805708104652, 0.911074734055176, 0.912335184623323, 0.913587047945251, 0.914830312237946, 0.916064965799332, 
0.917290997008378, 0.918508394325212, 0.919717146291227, 0.920917241529190, 0.922108668743345, 0.923291416719528, 0.924465474325263, 
0.925630830509873, 0.926787474304582, 0.927935394822618, 0.929074581259316, 0.930205022892219, 0.931326709081180, 0.932439629268462, 
0.933543772978836, 0.934639129819681, 0.935725689481080, 0.936803441735922, 0.937872376439990, 0.938932483532064, 0.939983753034014, 
0.941026175050889, 0.942059739771017, 0.943084437466093, 0.944100258491273, 0.945107193285261, 0.946105232370403, 0.947094366352777, 
0.948074585922276, 0.949045881852701, 0.950008245001843, 0.950961666311575, 0.951906136807932, 0.952841647601199, 0.953768189885990, 
0.954685754941338, 0.955594334130771, 0.956493918902395, 0.957384500788976, 0.958266071408018, 0.959138622461842, 0.960002145737666, 
0.960856633107680, 0.961702076529123, 0.962538468044359, 0.963365799780954, 0.964184063951746, 0.964993252854920, 0.965793358874084, 
0.966584374478333, 0.967366292222329, 0.968139104746362, 0.968902804776429, 0.969657385124292, 0.970402838687556, 0.971139158449725, 
0.971866337480279, 0.972584368934732, 0.973293246054698, 0.973992962167956, 0.974683510688511, 0.975364885116657, 0.976037079039039, 
0.976700086128712, 0.977353900145200, 0.977998514934557, 0.978633924429423, 0.979260122649082, 0.979877103699518, 0.980484861773469, 
0.981083391150487, 0.981672686196983, 0.982252741366289, 0.982823551198705, 0.983385110321551, 0.983937413449219, 0.984480455383221, 
0.985014231012240, 0.985538735312176, 0.986053963346195, 0.986559910264775, 0.987056571305751, 0.987543941794359, 0.988022017143284, 
0.988490792852697, 0.988950264510303, 0.989400427791380, 0.989841278458821, 0.990272812363169, 0.990695025442665, 0.991107913723277, 
0.991511473318744, 0.991905700430609, 0.992290591348257, 0.992666142448948, 0.993032350197851, 0.993389211148081, 0.993736721940725, 
0.994074879304879, 0.994403680057679, 0.994723121104326, 0.995033199438119, 0.995333912140482, 0.995625256380994, 0.995907229417412, 
0.996179828595697, 0.996443051350043, 0.996696895202896, 0.996941357764982, 0.997176436735326, 0.997402129901275, 0.997618435138520, 
0.997825350411112, 0.998022873771486, 0.998211003360478, 0.998389737407340, 0.998559074229759, 0.998719012233873, 0.998869549914284, 
0.999010685854073, 0.999142418724817, 0.999264747286594, 0.999377670388003, 0.999481186966167, 0.999575296046749, 0.999659996743959, 
0.999735288260562, 0.999801169887884, 0.999857641005824, 0.999904701082853, 0.999942349676024, 0.999970586430974, 0.999989411081928, 
0.999998823451702, 0.999998823451702, 0.999989411081928, 0.999970586430974, 0.999942349676024, 0.999904701082853, 0.999857641005824, 
0.999801169887884, 0.999735288260562, 0.999659996743959, 0.999575296046749, 0.999481186966167, 0.999377670388003, 0.999264747286594, 
0.999142418724817, 0.999010685854073, 0.998869549914284, 0.998719012233873, 0.998559074229759, 0.998389737407340, 0.998211003360478, 
0.998022873771486, 0.997825350411112, 0.997618435138520, 0.997402129901275, 0.997176436735326, 0.996941357764982, 0.996696895202896, 
0.996443051350043, 0.996179828595697, 0.995907229417412, 0.995625256380994, 0.995333912140482, 0.995033199438119, 0.994723121104326, 
0.994403680057679, 0.994074879304879, 0.993736721940725, 0.993389211148081, 0.993032350197851, 0.992666142448948, 0.992290591348257, 
0.991905700430609, 0.991511473318744, 0.991107913723277, 0.990695025442665, 0.990272812363169, 0.989841278458821, 0.989400427791380, 
0.988950264510303, 0.988490792852697, 0.988022017143284, 0.987543941794359, 0.987056571305751, 0.986559910264776, 0.986053963346195, 
0.985538735312176, 0.985014231012240, 0.984480455383221, 0.983937413449219, 0.983385110321551, 0.982823551198705, 0.982252741366289, 
0.981672686196983, 0.981083391150487, 0.980484861773469, 0.979877103699518, 0.979260122649082, 0.978633924429423, 0.977998514934557, 
0.977353900145200, 0.976700086128712, 0.976037079039039, 0.975364885116657, 0.974683510688511, 0.973992962167956, 0.973293246054698, 
0.972584368934732, 0.971866337480279, 0.971139158449725, 0.970402838687556, 0.969657385124292, 0.968902804776429, 0.968139104746362, 
0.967366292222329, 0.966584374478333, 0.965793358874084, 0.964993252854920, 0.964184063951746, 0.963365799780954, 0.962538468044359, 
0.961702076529123, 0.960856633107680, 0.960002145737666, 0.959138622461842, 0.958266071408018, 0.957384500788976, 0.956493918902395, 
0.955594334130771, 0.954685754941338, 0.953768189885990, 0.952841647601199, 0.951906136807932, 0.950961666311575, 0.950008245001843, 
0.949045881852701, 0.948074585922276, 0.947094366352777, 0.946105232370403, 0.945107193285261, 0.944100258491273, 0.943084437466093, 
0.942059739771017, 0.941026175050889, 0.939983753034014, 0.938932483532064, 0.937872376439990, 0.936803441735922, 0.935725689481080, 
0.934639129819681, 0.933543772978836, 0.932439629268462, 0.931326709081181, 0.930205022892219, 0.929074581259316, 0.927935394822618, 
0.926787474304582, 0.925630830509873, 0.924465474325263, 0.923291416719528, 0.922108668743345, 0.920917241529190, 0.919717146291227, 
0.918508394325212, 0.917290997008378, 0.916064965799332, 0.914830312237946, 0.913587047945251, 0.912335184623323, 0.911074734055176, 
0.909805708104652, 0.908528118716306, 0.907241977915296, 0.905947297807269, 0.904644090578246, 0.903332368494512, 0.902012143902493, 
0.900683429228647, 0.899346236979342, 0.898000579740740, 0.896646470178680, 0.895283921038557, 0.893912945145203, 0.892533555402765, 
0.891145764794583, 0.889749586383073, 0.888345033309596, 0.886932118794342, 0.885510856136200, 0.884081258712635, 0.882643339979563, 
0.881197113471222, 0.879742592800047, 0.878279791656542, 0.876808723809146, 0.875329403104111, 0.873841843465367, 0.872346058894392, 
0.870842063470079, 0.869329871348607, 0.867809496763303, 0.866280954024513, 0.864744257519462, 0.863199421712124, 0.861646461143081, 
0.860085390429390, 0.858516224264443, 0.856938977417829, 0.855353664735196, 0.853760301138112, 0.852158901623920, 0.850549481265603, 
0.848932055211640, 0.847306638685859, 0.845673246987299, 0.844031895490066, 0.842382599643186, 0.840725374970458, 0.839060237070313, 
0.837387201615662, 0.835706284353753, 0.834017501106018, 0.832320867767930, 0.830616400308846, 0.828904114771865, 0.827184027273669, 
0.825456154004378, 0.823720511227392, 0.821977115279241, 0.820225982569435, 0.818467129580299, 0.816700572866828, 0.814926329056527, 
0.813144414849254, 0.811354847017064, 0.809557642404051, 0.807752817926190, 0.805940390571176, 0.804120377398266, 0.802292795538116, 
0.800457662192623, 0.798614994634761, 0.796764810208419, 0.794907126328237, 0.793041960479444, 0.791169330217690, 0.789289253168886, 
0.787401747029031, 0.785506829564054, 0.783604518609638, 0.781694832071059, 0.779777787923014, 0.777853404209453, 0.775921699043408, 
0.773982690606823, 0.772036397150385, 0.770082836993348, 0.768122028523366, 0.766153990196313, 0.764178740536117, 0.762196298134579, 
0.760206681651202, 0.758209909813015, 0.756206001414395, 0.754194975316889, 0.752176850449043, 0.750151645806215, 0.748119380450404, 
0.746080073510064, 0.744033744179929, 0.741980411720831, 0.739920095459516, 0.737852814788466, 0.735778589165713, 0.733697438114660, 
0.731609381223893, 0.729514438146997, 0.727412628602376, 0.725303972373061, 0.723188489306528, 0.721066199314508, 0.718937122372804, 
0.716801278521100, 0.714658687862769, 0.712509370564692, 0.710353346857062, 0.708190637033196, 0.706021261449340, 0.703845240524485, 
0.701662594740169, 0.699473344640284, 0.697277510830887, 0.695075113980001, 0.692866174817425, 0.690650714134535, 0.688428752784090, 
0.686200311680039, 0.683965411797316, 0.681724074171650, 0.679476319899365, 0.677222170137181, 0.674961646102012, 0.672694769070773, 
0.670421560380173, 0.668142041426519, 0.665856233665510, 0.663564158612040, 0.661265837839992, 0.658961292982038, 0.656650545729429, 
0.654333617831801, 0.652010531096960, 0.649681307390683, 0.647345968636512, 0.645004536815544, 0.642657033966227, 0.640303482184152, 
0.637943903621844, 0.635578320488556, 0.633206755050057, 0.630829229628424, 0.628445766601833, 0.626056388404344, 0.623661117525695, 
0.621259976511088, 0.618852987960976, 0.616440174530854, 0.614021558931038, 0.611597163926462, 0.609167012336453, 0.606731127034525, 
0.604289530948156, 0.601842247058580, 0.599389298400565, 0.596930708062197, 0.594466499184664, 0.591996694962041, 0.589521318641064, 
0.587040393520918, 0.584553942953015, 0.582061990340776, 0.579564559139406, 0.577061672855679, 0.574553355047716, 0.572039629324757, 
0.569520519346947, 0.566996048825109, 0.564466241520519, 0.561931121244690, 0.559390711859136, 0.556845037275160, 0.554294121453620, 
0.551737988404708, 0.549176662187720, 0.546610166910835, 0.544038526730884, 0.541461765853123, 0.538879908531008, 0.536292979065963, 
0.533701001807153, 0.531104001151255, 0.528502001542228, 0.525895027471085, 0.523283103475657, 0.520666254140367, 0.518044504095999, 
0.515417878019463, 0.512786400633563, 0.510150096706767, 0.507508991052971, 0.504863108531268, 0.502212474045711, 0.499557112545082, 
0.496897049022655, 0.494232308515960, 0.491562916106550, 0.488888896919763, 0.486210276124487, 0.483527078932919, 0.480839330600334, 
0.478147056424843, 0.475450281747156, 0.472749031950343, 0.470043332459596, 0.467333208741989, 0.464618686306238, 0.461899790702463, 
0.459176547521944, 0.456448982396884, 0.453717121000164, 0.450980989045104, 0.448240612285220, 0.445496016513982, 0.442747227564570, 
0.439994271309633, 0.437237173661044, 0.434475960569656, 0.431710658025057, 0.428941292055330, 0.426167888726800, 0.423390474143796, 
0.420609074448403, 0.417823715820212, 0.415034424476082, 0.412241226669883, 0.409444148692258, 0.406643216870369, 0.403838457567654, 
0.401029897183576, 0.398217562153374, 0.395401478947817, 0.392581674072951, 0.389758174069856, 0.386931005514389, 0.384100195016935, 
0.381265769222162, 0.378427754808766, 0.375586178489217, 0.372741067009516, 0.369892447148934, 0.367040345719767, 0.364184789567080, 
0.361325805568454, 0.358463420633737, 0.355597661704784, 0.352728555755211, 0.349856129790135, 0.346980410845924, 0.344101425989939, 
0.341219202320283, 0.338333766965541, 0.335445147084532, 0.332553369866044, 0.329658462528587, 0.326760452320132, 0.323859366517853, 
0.320955232427875, 0.318048077385015, 0.315137928752523, 0.312224813921825, 0.309308760312269, 0.306389795370861, 0.303467946572011, 
0.300543241417274, 0.297615707435086, 0.294685372180514, 0.291752263234989, 0.288816408206050, 0.285877834727081, 0.282936570457055, 
0.279992643080273, 0.277046080306100, 0.274096909868706, 0.271145159526808, 0.268190857063403, 0.265234030285512, 0.262274707023914, 
0.259312915132886, 0.256348682489943, 0.253382036995570, 0.250413006572965, 0.247441619167773, 0.244467902747824, 0.241491885302869, 
0.238513594844319, 0.235533059404976, 0.232550307038775, 0.229565365820519, 0.226578263845610, 0.223589029229790, 0.220597690108874, 
0.217604274638484, 0.214608810993787, 0.211611327369228, 0.208611851978264, 0.205610413053099, 0.202607038844421, 0.199601757621131, 
0.196594597670080, 0.193585587295804, 0.190574754820253, 0.187562128582530, 0.184547736938620, 0.181531608261125, 0.178513770938997, 
0.175494253377271, 0.172473083996796, 0.169450291233968, 0.166425903540464, 0.163399949382973, 0.160372457242928, 0.157343455616239, 
0.154312973013020, 0.151281037957330, 0.148247678986896, 0.145212924652847, 0.142176803519448, 0.139139344163826, 0.136100575175706, 
0.133060525157139, 0.130019222722233, 0.126976696496886, 0.123932975118512, 0.120888087235777, 0.117842061508325, 0.114794926606510, 
0.111746711211127, 0.108697444013139, 0.105647153713411, 0.102595869022437, 0.099543618660069, 0.096490431355253, 0.093436335845748, 
0.090381360877865, 0.087325535206192, 0.084268887593324, 0.081211446809593, 0.078153241632794, 0.075094300847921, 0.072034653246889, 
0.068974327628267, 0.065913352797004, 0.062851757564161, 0.059789570746640, 0.056726821166908, 0.053663537652731, 0.050599749036899, 
0.047535484156960, 0.044470771854939, 0.041405640977077, 0.038340120373553, 0.035274238898214, 0.032208025408305, 0.029141508764194, 
0.026074717829104, 0.023007681468840, 0.019940428551514, 0.016872987947282, 0.013805388528061, 0.010737659167264, 0.007669828739531, 
0.004601926120449, 0.001533980186285];

const twiddleReal = [1.0000000000000000, 0.9996988186962042, 0.9987954562051724, 0.9972904566786902, 0.9951847266721969, 0.9924795345987100, 0.9891765099647810, 
0.9852776423889412, 0.9807852804032304, 0.9757021300385286, 0.9700312531945440, 0.9637760657954398, 0.9569403357322088, 0.9495281805930367, 
0.9415440651830208, 0.9329927988347390, 0.9238795325112867, 0.9142097557035307, 0.9039892931234433, 0.8932243011955153, 0.8819212643483550, 
0.8700869911087115, 0.8577286100002721, 0.8448535652497071, 0.8314696123025452, 0.8175848131515837, 0.8032075314806449, 0.7883464276266063, 
0.7730104533627370, 0.7572088465064846, 0.7409511253549591, 0.7242470829514670, 0.7071067811865476, 0.6895405447370669, 0.6715589548470183, 
0.6531728429537768, 0.6343932841636455, 0.6152315905806268, 0.5956993044924335, 0.5758081914178453, 0.5555702330196023, 0.5349976198870973, 
0.5141027441932217, 0.4928981922297841, 0.4713967368259978, 0.4496113296546066, 0.4275550934302822, 0.4052413140049899, 0.3826834323650898, 
0.3598950365349883, 0.3368898533922201, 0.3136817403988916, 0.2902846772544623, 0.2667127574748984, 0.2429801799032640, 0.2191012401568698, 
0.1950903220161283, 0.1709618887603014, 0.1467304744553617, 0.1224106751992163, 0.0980171403295608, 0.0735645635996675, 0.0490676743274181, 
0.0245412285229123, 0.0000000000000001, -0.0245412285229121, -0.0490676743274180, -0.0735645635996673, -0.0980171403295606, -0.1224106751992162, 
-0.1467304744553616, -0.1709618887603012, -0.1950903220161282, -0.2191012401568697, -0.2429801799032639, -0.2667127574748983, -0.2902846772544622, 
-0.3136817403988914, -0.3368898533922199, -0.3598950365349882, -0.3826834323650897, -0.4052413140049897, -0.4275550934302819, -0.4496113296546067, 
-0.4713967368259977, -0.4928981922297840, -0.5141027441932217, -0.5349976198870970, -0.5555702330196020, -0.5758081914178453, -0.5956993044924334, 
-0.6152315905806267, -0.6343932841636454, -0.6531728429537765, -0.6715589548470184, -0.6895405447370669, -0.7071067811865475, -0.7242470829514668, 
-0.7409511253549589, -0.7572088465064846, -0.7730104533627370, -0.7883464276266062, -0.8032075314806448, -0.8175848131515836, -0.8314696123025453, 
-0.8448535652497071, -0.8577286100002720, -0.8700869911087113, -0.8819212643483549, -0.8932243011955152, -0.9039892931234433, -0.9142097557035307, 
-0.9238795325112867, -0.9329927988347388, -0.9415440651830207, -0.9495281805930367, -0.9569403357322088, -0.9637760657954398, -0.9700312531945440, 
-0.9757021300385285, -0.9807852804032304, -0.9852776423889412, -0.9891765099647810, -0.9924795345987100, -0.9951847266721968, -0.9972904566786902, 
-0.9987954562051724, -0.9996988186962042];

const twiddleImag = [0.0000000000000000, -0.0245412285229123, -0.0490676743274180, -0.0735645635996674, -0.0980171403295606, -0.1224106751992162, -0.1467304744553617, 
-0.1709618887603012, -0.1950903220161282, -0.2191012401568698, -0.2429801799032639, -0.2667127574748984, -0.2902846772544623, -0.3136817403988915, 
-0.3368898533922201, -0.3598950365349881, -0.3826834323650898, -0.4052413140049899, -0.4275550934302821, -0.4496113296546065, -0.4713967368259976, 
-0.4928981922297840, -0.5141027441932217, -0.5349976198870972, -0.5555702330196022, -0.5758081914178453, -0.5956993044924334, -0.6152315905806268, 
-0.6343932841636455, -0.6531728429537768, -0.6715589548470183, -0.6895405447370668, -0.7071067811865475, -0.7242470829514669, -0.7409511253549591, 
-0.7572088465064845, -0.7730104533627370, -0.7883464276266062, -0.8032075314806448, -0.8175848131515837, -0.8314696123025452, -0.8448535652497070, 
-0.8577286100002721, -0.8700869911087113, -0.8819212643483549, -0.8932243011955153, -0.9039892931234433, -0.9142097557035307, -0.9238795325112867, 
-0.9329927988347388, -0.9415440651830208, -0.9495281805930367, -0.9569403357322089, -0.9637760657954398, -0.9700312531945440, -0.9757021300385286, 
-0.9807852804032304, -0.9852776423889412, -0.9891765099647810, -0.9924795345987100, -0.9951847266721968, -0.9972904566786902, -0.9987954562051724, 
-0.9996988186962042, -1.0000000000000000, -0.9996988186962042, -0.9987954562051724, -0.9972904566786902, -0.9951847266721969, -0.9924795345987100, 
-0.9891765099647810, -0.9852776423889412, -0.9807852804032304, -0.9757021300385286, -0.9700312531945440, -0.9637760657954398, -0.9569403357322089, 
-0.9495281805930367, -0.9415440651830208, -0.9329927988347388, -0.9238795325112867, -0.9142097557035307, -0.9039892931234434, -0.8932243011955152, 
-0.8819212643483550, -0.8700869911087115, -0.8577286100002721, -0.8448535652497072, -0.8314696123025455, -0.8175848131515837, -0.8032075314806449, 
-0.7883464276266063, -0.7730104533627371, -0.7572088465064847, -0.7409511253549590, -0.7242470829514669, -0.7071067811865476, -0.6895405447370671, 
-0.6715589548470186, -0.6531728429537766, -0.6343932841636455, -0.6152315905806269, -0.5956993044924335, -0.5758081914178454, -0.5555702330196022, 
-0.5349976198870972, -0.5141027441932218, -0.4928981922297841, -0.4713967368259979, -0.4496113296546069, -0.4275550934302820, -0.4052413140049899, 
-0.3826834323650899, -0.3598950365349883, -0.3368898533922203, -0.3136817403988914, -0.2902846772544624, -0.2667127574748985, -0.2429801799032641, 
-0.2191012401568700, -0.1950903220161286, -0.1709618887603012, -0.1467304744553618, -0.1224106751992163, -0.0980171403295608, -0.0735645635996677, 
-0.0490676743274180, -0.0245412285229123];

const cosines = [0.2499999264657206, 0.2499940437467244, 0.2499787488932784, 0.2499540424812251, 0.2499199254407470, 0.2498763990563313, 0.2498234649667219, 
0.2497611251648573, 0.2496893819977958, 0.2496082381666271, 0.2495176967263706, 0.2494177610858603, 0.2493084350076166, 0.2491897226077045, 
0.2490616283555789, 0.2489241570739159, 0.2487773139384315, 0.2486211044776869, 0.2484555345728799, 0.2482806104576239, 0.2480963387177129, 
0.2479027262908738, 0.2476997804665051, 0.2474875088854022, 0.2472659195394704, 0.2470350207714231, 0.2467948212744686, 0.2465453300919821, 
0.2462865566171656, 0.2460185105926941, 0.2457412021103491, 0.2454546416106381, 0.2451588398824020, 0.2448538080624087, 0.2445395576349338, 
0.2442161004313282, 0.2438834486295728, 0.2435416147538201, 0.2431906116739221, 0.2428304526049465, 0.2424611511066787, 0.2420827210831113, 
0.2416951767819208, 0.2412985327939312, 0.2408928040525643, 0.2404780058332781, 0.2400541537529909, 0.2396212637694940, 0.2391793521808508, 
0.2387284356247826, 0.2382685310780430, 0.2377996558557783, 0.2373218276108755, 0.2368350643332980, 0.2363393843494081, 0.2358348063212769, 
0.2353213492459822, 0.2347990324548925, 0.2342678756129398, 0.2337278987178790, 0.2331791220995351, 0.2326215664190374, 0.2320552526680424, 
0.2314802021679425, 0.2308964365690642, 0.2303039778498522, 0.2297028483160425, 0.2290930705998223, 0.2284746676589779, 0.2278476627760306, 
0.2272120795573598, 0.2265679419323144, 0.2259152741523120, 0.2252541007899256, 0.2245844467379586, 0.2239063372085075, 0.2232197977320129, 
0.2225248541562981, 0.2218215326455958, 0.2211098596795634, 0.2203898620522859, 0.2196615668712670, 0.2189250015564086, 0.2181801938389786, 
0.2174271717605664, 0.2166659636720278, 0.2158965982324170, 0.2151191044079080, 0.2143335114707039, 0.2135398489979347, 0.2127381468705439, 
0.2119284352721636, 0.2111107446879777, 0.2102851059035745, 0.2094515500037877, 0.2086101083715258, 0.2077608126865906, 0.2069036949244846, 
0.2060387873552072, 0.2051661225420394, 0.2042857333403182, 0.2033976528961996, 0.2025019146454103, 0.2015985523119891, 0.2006875999070173, 
0.1997690917273381, 0.1988430623542653, 0.1979095466522815, 0.1969685797677251, 0.1960201971274675, 0.1950644344375791, 0.1941013276819851, 
0.1931309131211103, 0.1921532272905146, 0.1911683069995168, 0.1901761893298092, 0.1891769116340614, 0.1881705115345138, 0.1871570269215614, 
0.1861364959523268, 0.1851089570492245, 0.1840744488985133, 0.1830330104488403, 0.1819846809097747, 0.1809294997503309, 0.1798675066974833, 
0.1787987417346700, 0.1777232451002879, 0.1766410572861774, 0.1755522190360980, 0.1744567713441944, 0.1733547554534530, 0.1722462128541493, 
0.1711311852822856, 0.1700097147180198, 0.1688818433840847, 0.1677476137441986, 0.1666070685014663, 0.1654602505967717, 0.1643072032071607, 
0.1631479697442156, 0.1619825938524214, 0.1608111194075215, 0.1596335905148667, 0.1584500515077543, 0.1572605469457590, 0.1560651216130552, 
0.1548638205167310, 0.1536566888850938, 0.1524437721659671, 0.1512251160249800, 0.1500007663438473, 0.1487707692186425, 0.1475351709580622, 
0.1462940180816826, 0.1450473573182079, 0.1437952356037113, 0.1425377000798676, 0.1412747980921785, 0.1400065771881901, 0.1387330851157026, 
0.1374543698209728, 0.1361704794469087, 0.1348814623312573, 0.1335873670047844, 0.1322882421894477, 0.1309841367965621, 0.1296750999249587, 
0.1283611808591358, 0.1270424290674037, 0.1257188942000217, 0.1243906260873298, 0.1230576747378715, 0.1217200903365118, 0.1203779232425475, 
0.1190312239878109, 0.1176800432747679, 0.1163244319746086, 0.1149644411253324, 0.1136001219298259, 0.1122315257539358, 0.1108587041245346, 
0.1094817087275807, 0.1081005914061725, 0.1067154041585966, 0.1053261991363699, 0.1039330286422764, 0.1025359451283975, 0.1011350011941382, 
0.0997302495842457, 0.0983217431868241, 0.0969095350313432, 0.0954936782866418, 0.0940742262589262, 0.0926512323897629, 0.0912247502540668, 
0.0897948335580841, 0.0883615361373702, 0.0869249119547628, 0.0854850150983505, 0.0840418997794361, 0.0825956203304957, 0.0811462312031330, 
0.0796937869660296, 0.0782383423028900, 0.0767799520103833, 0.0753186709960795, 0.0738545542763830, 0.0723876569744607, 0.0709180343181671, 
0.0694457416379644, 0.0679708343648399, 0.0664933680282189, 0.0650133982538738, 0.0635309807618302, 0.0620461713642687, 0.0605590259634240, 
0.0590696005494799, 0.0575779511984614, 0.0560841340701234, 0.0545882054058366, 0.0530902215264696, 0.0515902388302689, 0.0500883137907351, 
0.0485845029544971, 0.0470788629391830, 0.0455714504312883, 0.0440623221840420, 0.0425515350152695, 0.0410391458052540, 0.0395252114945942, 
0.0380097890820615, 0.0364929356224530, 0.0349747082244443, 0.0334551640484387, 0.0319343603044156, 0.0304123542497764, 0.0288892031871888, 
0.0273649644624295, 0.0258396954622249, 0.0243134536120908, 0.0227862963741702, 0.0212582812450700, 0.0197294657536962, 0.0181999074590879, 
0.0166696639482504, 0.0151387928339869, 0.0136073517527298, 0.0120753983623700, 0.0105429903400870, 0.0090101853801766, 0.0074770411918791, 
0.0059436154972069, 0.0044099660287705, 0.0028761505276057, 0.0013422267409991];

const sines = [0.0001917475796857, 0.0017257146811824, 0.0032596168104968, 0.0047933962170807, 0.0063269951550061, 0.0078603558851401, 0.0093934206773176, 
0.0109261318125159, 0.0124584315850268, 0.0139902623046301, 0.0155215662987650, 0.0170522859147016, 0.0185823635217114, 0.0201117415132375, 
0.0216403623090628, 0.0231681683574783, 0.0246951021374499, 0.0262211061607837, 0.0277461229742908, 0.0292700951619501, 0.0307929653470701, 
0.0323146761944490, 0.0338351704125335, 0.0353543907555758, 0.0368722800257884, 0.0383887810754984, 0.0399038368092983, 0.0414173901861960, 
0.0429293842217625, 0.0444397619902768, 0.0459484666268696, 0.0474554413296641, 0.0489606293619145, 0.0504639740541420, 0.0519654188062688, 
0.0534649070897484, 0.0549623824496947, 0.0564577885070065, 0.0579510689604912, 0.0594421675889835, 0.0609310282534630, 0.0624175948991671, 
0.0639018115577019, 0.0653836223491489, 0.0668629714841694, 0.0683398032661047, 0.0698140620930728, 0.0712856924600622, 0.0727546389610213, 
0.0742208462909446, 0.0756842592479548, 0.0771448227353813, 0.0786024817638342, 0.0800571814532750, 0.0815088670350826, 0.0829574838541153, 
0.0844029773707687, 0.0858452931630288, 0.0872843769285213, 0.0887201744865557, 0.0901526317801656, 0.0915816948781434, 0.0930073099770713, 
0.0944294234033464, 0.0958479816152022, 0.0972629312047236, 0.0986742188998584, 0.1000817915664225, 0.1014855962101006, 0.1028855799784413, 
0.1042816901628470, 0.1056738742005583, 0.1070620796766330, 0.1084462543259196, 0.1098263460350250, 0.1112023028442762, 0.1125740729496772, 
0.1139416047048587, 0.1153048466230231, 0.1166637473788827, 0.1180182558105922, 0.1193683209216745, 0.1207138918829414, 0.1220549180344067, 
0.1233913488871937, 0.1247231341254361, 0.1260502236081726, 0.1273725673712341, 0.1286901156291253, 0.1300028187768990, 0.1313106273920237, 
0.1326134922362441, 0.1339113642574352, 0.1352041945914491, 0.1364919345639544, 0.1377745356922689, 0.1390519496871850, 0.1403241284547879, 
0.1415910240982659, 0.1428525889197143, 0.1441087754219305, 0.1453595363102025, 0.1466048244940901, 0.1478445930891969, 0.1490787954189359, 
0.1503073850162871, 0.1515303156255465, 0.1527475412040679, 0.1539590159239962, 0.1551646941739930, 0.1563645305609536, 0.1575584799117161, 
0.1587464972747624, 0.1599285379219101, 0.1611045573499971, 0.1622745112825565, 0.1634383556714840, 0.1645960466986963, 0.1657475407777804, 
0.1668927945556350, 0.1680317649141029, 0.1691644089715937, 0.1702906840846989, 0.1714105478497969, 0.1725239581046500, 0.1736308729299914, 
0.1747312506511035, 0.1758250498393872, 0.1769122293139211, 0.1779927481430125, 0.1790665656457383, 0.1801336413934763, 0.1811939352114278, 
0.1822474071801298, 0.1832940176369582, 0.1843337271776207, 0.1853664966576408, 0.1863922871938314, 0.1874110601657584, 0.1884227772171953, 
0.1894274002575670, 0.1904248914633838, 0.1914152132796656, 0.1923983284213557, 0.1933741998747248, 0.1943427908987641, 0.1953040650265690, 
0.1962579860667120, 0.1972045181046050, 0.1981436255038519, 0.1990752729075898, 0.1999994252398204, 0.2009160477067310, 0.2018251057980036, 
0.2027265652881149, 0.2036203922376247, 0.2045065529944534, 0.2053850141951494, 0.2062557427661451, 0.2071187059250018, 0.2079738711816444, 
0.2088212063395843, 0.2096606794971318, 0.2104922590485969, 0.2113159136854796, 0.2121316123976482, 0.2129393244745073, 0.2137390195061537, 
0.2145306673845216, 0.2153142383045156, 0.2160897027651335, 0.2168570315705767, 0.2176161958313494, 0.2183671669653462, 0.2191099166989284, 
0.2198444170679883, 0.2205706404190022, 0.2212885594100713, 0.2219981470119514, 0.2226993765090704, 0.2233922215005340, 0.2240766559011199, 
0.2247526539422598, 0.2254201901730094, 0.2260792394610071, 0.2267297769934195, 0.2273717782778764, 0.2280052191433921, 0.2286300757412761, 
0.2292463245460307, 0.2298539423562368, 0.2304529062954270, 0.2310431938129478, 0.2316247826848076, 0.2321976510145143, 0.2327617772338988, 
0.2333171401039280, 0.2338637187155037, 0.2344014924902500, 0.2349304411812883, 0.2354505448739994, 0.2359617839867732, 0.2364641392717460, 
0.2369575918155253, 0.2374421230399017, 0.2379177147025485, 0.2383843488977083, 0.2388420080568676, 0.2392906749494176, 0.2397303326833033, 
0.2401609647056596, 0.2405825548034344, 0.2409950871039985, 0.2413985460757442, 0.2417929165286692, 0.2421781836149487, 0.2425543328294948, 
0.2429213500105021, 0.2432792213399813, 0.2436279333442790, 0.2439674728945853, 0.2442978272074281, 0.2446189838451542, 0.2449309307163978, 
0.2452336560765354, 0.2455271485281284, 0.2458113970213518, 0.2460863908544105, 0.2463521196739421, 0.2466085734754068, 0.2468557426034639, 
0.2470936177523353, 0.2473221899661563, 0.2475414506393121, 0.2477513915167623, 0.2479520046943516, 0.2481432826191072, 0.2483252180895233, 
0.2484978042558323, 0.2486610346202627, 0.2488149030372833, 0.2489594037138354, 0.2490945312095501, 0.2492202804369535, 0.2493366466616583, 
0.2494436255025420, 0.2495412129319116, 0.2496294052756556, 0.2497081992133820, 0.2497775917785437, 0.2498375803585499, 0.2498881626948642, 
0.2499293368830905, 0.2499611013730438, 0.2499834549688090, 0.2499963968287858];

const mirrored = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 
24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 
12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 
18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 
6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 
30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 
9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 
21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 
3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 
27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 
15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];`;


const coreFunctionString = `

let bitPercent = 15;
let samplingRate = 44100;
let dynamicRange = 96;
let frequencyRange = 0;
let topBitLimit = 0;
let bottomBitLimit = 0;
let mostImportant = 800;
let transientThreshold = 2.5;
let bandSize = 8;
let keyframeGap = 2;
let adaptiveAllocation = 1;
let highStart = 92;
let highStop = 463;
let noiseFloor = 40000;
let subbandFreq = 344.53125;
let lastLow = 2;
let regionSteps = [dynamicRange - 15, dynamicRange - 25, dynamicRange - 35, dynamicRange - 50];

let savedBits = 0;

function binConvert(numb, dSize)
 {
 numb = Math.round(numb);
 if(dSize == 1)
  {
  return [numb & 255];
  }
 let outBytes = [];
 let bitVal = Math.pow(2, dSize * 8);
 if(numb < 0)
  {
  numb += bitVal;
  }
 for(let i=0; i<dSize; i++)
  {
  outBytes.push(numb & 255);
  numb >>= 8;
  }
 return outBytes;
 }

function byteFormat(bitStream, lenData, totalBytes, bit)
 {
 let at = 0;
 let result = new Array(totalBytes).fill(0);
 for(let i=0; i<bitStream.length; i++)
  {
  let val = bitStream[i];
  let len = lenData[i];
  let bytes = Math.ceil((len + bit) / 8);
  let adjust = (bytes << 3) - len - bit;
  result[at + bytes - 1] |= (val << adjust) & 255;
  if(bytes > 1)
   {
   val >>= 8 - adjust;
   result[at + bytes - 2] |= val & 255;
   if(bytes == 3)
    {
    val >>= 8;
    result[at] |= val & 255;
    }
   }
  bit += len;
  at += bit >> 3;
  bit &= 7;
  }
 return result;
 }

function insert(currentBytes, newValue, len, byteCount, bit)
 {
 let adjust = (byteCount << 3) - len - bit;
 currentBytes[byteCount - 1] |= (newValue << adjust) & 255;
 if(byteCount > 1)
  {
  newValue >>= 8 - adjust;
  currentBytes[byteCount - 2] |= newValue & 255;
  }
 if(byteCount == 3)
  {
  newValue >>= 8;
  currentBytes[0] |= newValue & 255;
  }
 return currentBytes;
 }

function createFrame(frameNumb, selChannel, prevHighTones, forceTransient)
 {
 let MDCT = FMDCT(getFrame(frameNumb, selChannel));
 let analyze = dBconvert(MDCT);
 let highContent = analyze.highTones > noiseFloor ? analyze.highTones : noiseFloor;
 let transientDetected = (transientThreshold > 10 || prevHighTones == -1) ? false : (highContent / prevHighTones) > transientThreshold;
 let handleTransient = transientDetected || forceTransient;
 let signalMaskData = bitPercent >= 100 ? getSNR(analyze.magnitudes) : getSMR(analyze.magnitudes, handleTransient);
 let subbandCount = signalMaskData.actualSubbands;
 let allocBits = allocate(signalMaskData.bandMaxes, signalMaskData.absoluteMax, signalMaskData.nonZeroCount, subbandCount);
 let scaled = quantize(MDCT, allocBits.limitedBits, allocBits.allocOrder, allocBits.bitsPerBand, allocBits.bitLimit, signalMaskData.nonZeroCoeffs, subbandCount);
 scaled.transient = transientDetected;
 scaled.high = highContent;
 return scaled;
 }

function dBconvert(coeffs)
 {
 let absVal = new Array(512);
 let highSum = 0;
 for(let i=0; i<512; i++)
  {
  let single = Math.abs(coeffs[i]);
  if(i >= highStart && i <= highStop)
   {
   highSum += single;
   }
  absVal[i] = single;
  }
 let top = Math.max.apply(Math, absVal);
 if(top < 0.001)
  {
  return {magnitudes: absVal.fill(-150), highTones: 0};
  }
 let result = new Array(512);
 for(let i=0; i<512; i++)
  {
  let magnitude = absVal[i] == 0 ? 0.001 : absVal[i];
  let dB = 20 * Math.log10(magnitude / top);
  if(dB < -150)
   {
   dB = -150;
   }
  result[i] = dB + dynamicRange;
  }
 return {magnitudes: result, highTones: highSum};
 }
 

function getFrame(which, channel)
 {
 let offset = which * 512 * audioChannels + channel;
 let sliced = new Array(1024);
 let at = offset;
 for(let i=0; i<1024; i++)
  {
  sliced[i] = audioBuffer[at];
  at += audioChannels;
  }
 return sliced;
 }

function getSMR(data, handleTransient)
 {
 let setCutoff = frequencyRange == 0 ? cutoff(bitPercent) : frequencyRange;
 let analyzeRange_1 = freqToCoeff(setCutoff, samplingRate);
 let analyzeRange = analyzeRange_1 + 1;
 let peaks = new Array(analyzeRange);
 let foundTonal = new Array(analyzeRange);
 let foundNoise = new Array(analyzeRange);
 let tonalCount = 0;
 let noiseCount = 0;
 let peakCount = 0;
 let SPL = new Array(analyzeRange);
 let status = new Array(analyzeRange).fill(0);
 for(let i=0; i<analyzeRange; i++)
  {
  SPL[i] = data[i];
  }
 for(let i=1; i<analyzeRange_1; i++)
  {
  if(data[i] >= data[i + 1] && data[i] > data[i - 1])
   {
   peaks[peakCount++] = i;
   }
  }
 for(let i=0; i<peakCount; i++)
  {
  let tonal = true;
  let peakLoc = peaks[i];
  let verifyInd = peakLoc >> 7;
  if(verifyInd > 2){verifyInd = 2;}
  let verifyWidth = verifySizes[verifyInd];
  for(let j=0; j<verifyWidth; j++)
   {
   let check = peakLoc + tonalVerify[verifyInd][j];
   if(check < 0 || check > analyzeRange_1)
    {
	continue;
	}
   if(data[peakLoc] - data[check] < 5)
    {
	tonal = false;
	break;
	}
   }
  if(tonal)
   {
   let near = [-150, data[peakLoc], -150];
   if(peakLoc > 0)
    {
	near[0] = data[peakLoc - 1];
	}
   if(peakLoc < analyzeRange_1)
    {
	near[2] = data[peakLoc + 1];
	}
   let maskerSPL = add_dB(near, 3);
   if(maskerSPL < hearingThreshold(peakLoc, samplingRate))
    {
	continue;
	}
   SPL[peakLoc] = maskerSPL;
   foundTonal[tonalCount++] = peakLoc;
   status[peakLoc] = 1;
   }
  }
 for(let i=0; i<tonalCount; i++)
  {
  let checkTonal = foundTonal[i];
  let SPLcheck = SPL[checkTonal];
  let barkCheck = coeffToBark(checkTonal, samplingRate);
  for(let j=i+1; j<tonalCount; j++)
   {
   let next = foundTonal[j];
   let barkNext = coeffToBark(next, samplingRate);
   if(barkNext - barkCheck >= 0.5)
    {
	break;
	}
   let SPLnext = SPL[next];
   if(SPLcheck > SPLnext)
    {
	status[next] = 0;
	continue;
	}
   status[checkTonal] = 0;
   break;
   }
  if(!status[checkTonal])
   {
   continue;
   }
  let regionWidth = nonMaskSize(SPLcheck, true);
  let regionStart = checkTonal - regionWidth;
  let regionStop = checkTonal + regionWidth;
  for(let j=regionStart; j<regionStop; j++)
   {
   if(j < 0)
    {
	continue;
	}
   if(j > analyzeRange_1)
    {
	break;
	}
   if(SPLcheck - SPL[j] > 40)
    {
	continue;
	}
   if(status[j] != 1)
    {
	status[j] = 2;
	}
   }
  }
 let startCoeff = barkToCoeff(0, samplingRate);
 for(let i=0; i<25; i++)
  {
  let weighted = 0;
  let summed = -150;
  let stopCoeff = barkToCoeff(i + 1, samplingRate);
  if(stopCoeff <= startCoeff)
   {
   stopCoeff = startCoeff + 1;
   }
  for(let j=startCoeff; j<stopCoeff; j++)
   {
   if(status[j] == 1)
    {
	continue;
	}
   summed = add_dB([data[j], summed], 2);
   weighted += Math.pow(10, data[j] / 10) * (coeffToBark(j, samplingRate) - i);
   }
  if(summed > hearingThreshold(startCoeff, samplingRate) + 20)
   {
   let ind = weighted / Math.pow(10, summed / 10);
   let center = startCoeff + parseInt(ind * (stopCoeff - startCoeff));
   if(status[center] == 1)
    {
	center++;
	}
   if(center > analyzeRange_1)
    {
	break;
	}
   status[center] = 3;
   SPL[center] = summed;
   foundNoise[noiseCount++] = center;
   let regionWidth = nonMaskSize(summed, false);
   let regionStart = center - regionWidth;
   let regionStop = center + regionWidth;
   for(let j=regionStart; j<regionStop; j++)
    {
    if(j < 0)
     {
	 continue;
	 }
    if(j > analyzeRange_1)
     {
	 break;
	 }
    if(summed - SPL[j] > 40)
     {
	 continue;
	 }
	if(status[j] != 1 && status[j] != 3)
     {
	 status[j] = 2;
	 }
    }
   }
  if(stopCoeff >= analyzeRange_1)
   {
   break;
   }
  startCoeff = stopCoeff;
  }
 let tonalMaskers = 0;
 let noiseMaskers = 0;
 for(let i=0; i<analyzeRange; i++)
  {
  switch(status[i])
   {
   case 1:
    {
	foundTonal[tonalMaskers++] = i;
	}
   break;
   case 3:
    {
	foundNoise[noiseMaskers++] = i;
	}
   }
  }
 let maskingTonal = new Array(analyzeRange);
 let maskingNoise = new Array(analyzeRange);
 let singleTonal = new Array(tonalMaskers);
 let singleNoise = new Array(noiseMaskers);
 for(let i=0; i<analyzeRange; i++)
  {
  if(status[i])
   {
   maskingTonal[i] = -150;
   maskingNoise[i] = -150;
   continue;
   }
  let maskedBark = coeffToBark(i, samplingRate);
  for(let j=0; j<tonalMaskers; j++)
   {
   let maskerIndex = foundTonal[j];
   let maskerBark = coeffToBark(maskerIndex, samplingRate);
   let diff = maskedBark - maskerBark;
   if(diff < -3 || diff > 8 || (handleTransient && data[maskerIndex] - data[i] < 40))
    {
	singleTonal[j] = -150;
	continue;
	}
   let spreadFactor = -0.275 * maskerBark - 6.025;
   let proxFactor;
   if(diff >= -3 && diff < -1)
	{
	proxFactor = 17 * (diff + 1) - (data[maskerIndex] * 0.4 + 6);
	}
   else if(diff >= -1 && diff < 0)
    {
	proxFactor = diff * (data[maskerIndex] * 0.4 + 6);
	}
   else if(diff >= 0 && diff < 1)
	{
	proxFactor = -17 * diff;
	}
   else
	{
	proxFactor = -(diff - 1) * (17 - data[maskerIndex] * 0.15) - 17;
	}
   singleTonal[j] = data[maskerIndex] + spreadFactor + proxFactor;
   }
  for(let j=0; j<noiseMaskers; j++)
   {
   let maskerIndex = foundNoise[j];
   let maskerBark = coeffToBark(maskerIndex, samplingRate);
   let diff = maskedBark - maskerBark;
   if(diff < -3 || diff > 8 || (handleTransient && data[maskerIndex] - data[i] < 40))
    {
	singleNoise[j] = -150;
	continue;
	}
   let spreadFactor = -0.175 * maskerBark - 2.025;
   let proxFactor;
   if(diff >= -3 && diff < - 1)
	{
	proxFactor = 17 * (diff + 1) - (data[maskerIndex] * 0.4 + 6);
	}
   else if(diff >= -1 && diff < 0)
	{
	proxFactor = diff * (data[maskerIndex] * 0.4 + 6);
	}
   else if(diff >= 0 && diff < 1)
	{
	proxFactor = -17 * diff;
	}
   else
	{
	proxFactor = -(diff - 1) * (17 - data[maskerIndex] * 0.15) - 17;
	}
   singleNoise[j] = data[maskerIndex] + spreadFactor + proxFactor;
   }
  maskingTonal[i] = add_dB(singleTonal, tonalMaskers);
  maskingNoise[i] = add_dB(singleNoise, noiseMaskers);
  }
 let subbands = Math.ceil(analyzeRange / bandSize);
 let SMR = new Array(subbands * bandSize);
 let rejectBelow = SMRreject(bitPercent);
 let limitRange = dynamicLimit(bitPercent);
 let lastNonZero = 0;
 let at = 0;
 for(let i=0; i<subbands; i++)
  {
  let bandMax = -150;
  for(let j=0; j<bandSize; j++)
   {
   if(at > analyzeRange_1)
    {
	SMR[at++] = 0;
	continue;
	}
   let maskers = [maskingTonal[at], maskingNoise[at]];
   let singleThresh = add_dB(maskers, 2);
   let singleSMR = singleThresh > 0 ? data[at] - singleThresh : data[at];
   if(singleSMR > bandMax)
    {
	bandMax = singleSMR;
	}
   SMR[at++] = singleSMR;
   }
  if(bandMax <= 0)
   {
   continue;
   }
  at -= bandSize;
 for(let j=0; j<bandSize; j++)
   {
   let single = SMR[at];
   if(single >= rejectBelow && bandMax - single <= limitRange)
    {
	lastNonZero = at + 1;
	}
   else
    {
	SMR[at] = 0;
	}
   at++;
   }
  }
 let actualSubbands = Math.ceil(lastNonZero / bandSize);
 let nonZeroCoeffs = new Array(actualSubbands * bandSize);
 let bandMaxes = new Array(actualSubbands);
 let nonZeroCount = new Array(actualSubbands);
 at = 0;
 for(let i=0; i<actualSubbands; i++)
  {
  let bandMax = -150;
  let bandNonZero = 0;
  for(let j=0; j<bandSize; j++)
   {
   let single = SMR[at];
   let nonZero = single > 0;
   nonZeroCoeffs[at++] = nonZero;
   if(!nonZero)
    {
	continue;
	}
   bandNonZero++;
   if(single > bandMax)
    {
	bandMax = single;
	}
   }
  nonZeroCount[i] = bandNonZero;
  bandMaxes[i] = bandMax;
  }
 let absoluteMax = Math.max.apply(Math, bandMaxes);
 return {nonZeroCoeffs, absoluteMax, nonZeroCount, bandMaxes, actualSubbands};
 }

function getSNR(data)
 {
 let setCutoff = frequencyRange == 0 ? 24000 : frequencyRange;
 let analyzeRange = freqToCoeff(setCutoff, samplingRate) + 1;
 let subbands = Math.ceil(analyzeRange / bandSize);
 let SNR = new Array(subbands * bandSize);
 let nonZeroCoeffs = new Array(subbands * bandSize);
 let bandMaxes = new Array(subbands);
 let nonZeroCount = new Array(subbands);
 let lastNonZero = 0;
 let at = 0;
 for(let i=0; i<subbands; i++)
  {
  let bandMax = -150;
  for(let j=0; j<bandSize; j++)
   {
   if(at >= analyzeRange)
    {
	SNR[at++] = 0;
	continue;
	}
   let single = data[at];
   if(single > bandMax)
    {
	bandMax = single;
	}
   SNR[at++] = single;
   }
  bandMaxes[i] = bandMax;
  if(bandMax <= 0)
   {
   continue;
   }
  at -= bandSize;
  let bandNonZero = 0;
  for(let j=0; j<bandSize; j++)
   {
   let single = SNR[at];
   let nonZero = single > 0;
   nonZeroCoeffs[at] = nonZero;
   if(nonZero && bandMax - single <= dynamicRange)
    {
	lastNonZero = at + 1;
	}
   else
    {
	SNR[at] = 0;
	}
   at++;
   if(!nonZero)
    {
	continue;
	}
   bandNonZero++;
   }
  nonZeroCount[i] = bandNonZero;
  }
 let actualSubbands = Math.ceil(lastNonZero / bandSize);
 let absoluteMax = 96;
 return {nonZeroCoeffs, nonZeroCount, bandMaxes, absoluteMax, actualSubbands};
 }

function allocate(bandMaxSMR, bandAbsoluteMax, nonZeroCoeffs, subbands)
 {
 let bitsPerBand = new Array(subbands);
 let limitedBits = new Array(subbands);
 let allocOrder = new Array(subbands);
 let sortedSMR = new Array(subbands);
 let bitLimit = 0;
 let shrink = (bitPercent / 100) * 0.98 + 0.02;
 let lowest = -1;
 for(let i=0; i<subbands; i++)
  {
  let currentSMR = bandMaxSMR[i];
  let bitCount = reqBits(currentSMR);
  bitsPerBand[i] = bitCount;
  allocOrder[i] = i;
  sortedSMR[i] = currentSMR;
  if(bitCount)
   {
   let shrinkBits = Math.ceil(bitCount * shrink);
   if(shrinkBits < 2)
	{
	shrinkBits = 2;
	}
   if(currentSMR > bandAbsoluteMax - 10)
    {
	let importantBand = nonZeroCoeffs[i] > Math.round(bandSize / 1.5);
	if(shrinkBits < 5 && currentSMR > bandAbsoluteMax - 3)
	 {
	 if(i <= lastLow)
	  {
	  shrinkBits = importantBand ? 5 : 4;
	  }
	 else
	  {
	  shrinkBits = importantBand ? 4 : 3;
	  }
	 }
	else if(shrinkBits < 3 && importantBand)
	 {
	 shrinkBits = 3;
	 }
	}
   limitedBits[i] = adaptiveAllocation ? shrinkBits : 2;
   bitLimit += shrinkBits * nonZeroCoeffs[i];
   if(i == 0)
	{
	lowest++;
	continue;
	}
   let shuffleTo;
   if(mostImportant == 0)
    {
    shuffleTo = -1;
    }
   else
    {
    shuffleTo = lowest;
	if(i <= lastLow)
     {
	 lowest++;
	 }
    if(currentSMR == bandAbsoluteMax)
     {
	 shuffleTo = -1;
	 if(i > lastLow)
	  {
	  lowest++;
	  }
	 }
    }
   let j = i - 1;
   while(j > shuffleTo && sortedSMR[j] < currentSMR)
    {
    sortedSMR[j + 1] = sortedSMR[j];
    allocOrder[j + 1] = allocOrder[j];
    j--;
    }
   sortedSMR[j + 1] = currentSMR;
   allocOrder[j + 1] = i;
   continue;
   }
  limitedBits[i] = 0;
  }
 bitLimit = Math.ceil(bitLimit * shrinkBudget(bitPercent));
 let prevLim = bitLimit;
 if(topBitLimit != 0 && bitLimit > topBitLimit)
  {
  bitLimit = topBitLimit;
  }
 else if(bottomBitLimit != 0 && bitLimit < bottomBitLimit)
  {
  bitLimit = (bottomBitLimit > topBitLimit && topBitLimit != 0) ? topBitLimit : bottomBitLimit;
  }
 return {limitedBits, bitsPerBand, bitLimit, allocOrder};
 }

function quantize(MDCTcoeffs, allocData, allocOrder, idealAlloc, bitLimit, nonZeroData, subbands)
 {
 let band = new Array(bandSize);
 let bandAbs = new Array(bandSize);
 let bandMaxes = new Array(subbands);
 let usedPerBand = new Array(subbands);
 let baseFreq = subbandFreq / 2;
 let chosenFactors = new Array(subbands);
 let allocated = new Array(subbands);
 let included = new Array(subbands);
 let quantized = new Array(subbands * bandSize).fill(0);
 let decoded = new Array(subbands * bandSize).fill(0);
 let at = 0;
 let usedBits = 0;
 let includedBands = 0;
 let lastSubband = -1;
 let stopAt = 0;
 let bitsEnded = false;
 for(let i=0; i<subbands; i++)
  {
  if(bitsEnded)
   {
   for(let j=stopAt+1; j<subbands; j++)
    {
	allocated[allocOrder[j]] = 0;
	}
   break;
   }
  let allocNow = allocOrder[i];
  if(allocData[allocNow] == 0)
   {
   usedPerBand[allocNow] = 0;
   included[allocNow] = 0;
   allocated[allocNow] = 0;
   continue;
   }
  includedBands++;
  at = allocNow * bandSize;
  for(let j=0; j<bandSize; j++)
   {
   if(nonZeroData[at])
    {
	bandAbs[j] = Math.abs(MDCTcoeffs[at]);
	band[j] = MDCTcoeffs[at];
    }
   else
    {
	bandAbs[j] = 0;
	band[j] = 0;
	}
   at++;
   }
  let maxVal = Math.max.apply(Math, bandAbs);
  bandMaxes[allocNow] = maxVal;
  let bandFreq = subbandFreq * allocNow + baseFreq;
  let maxDiff = maxVal * allowedError(bitPercent, bandFreq) / 100;
  let result = optimizedQuant(band, maxVal, allocData[allocNow], maxDiff);
  let arrayInd = allocNow * bandSize;
  chosenFactors[allocNow] = result.factor;
  allocated[allocNow] = result.precision;
  for(let j=0; j<bandSize; j++)
   {
   quantized[arrayInd] = result.values[j];
   decoded[arrayInd++] = result.reconstructed[j];
   }
  usedBits += result.used;
  usedPerBand[allocNow] = result.used;
  included[allocNow] = result.notZeroed;
  if(allocNow > lastSubband)
   {
   lastSubband = allocNow;
   }
  if(usedBits > bitLimit)
   {
   stopAt = i;
   bitsEnded = true;
   }
  }
 let remain = bitLimit - usedBits;
 if(remain < 0)
  {
  remain = 0;
  }
 let distribute = remain + savedBits;
 if(distribute <= 0)
  {
  includedBands = 0;
  }
 for(let i=0; i<includedBands; i++)
  {
  if(distribute <= 0 && i > 1)
   {
   distribute = 0;
   break;
   }
  let refineNow = allocOrder[i];
  let offset = bandSize * refineNow;
  for(let j=0; j<bandSize; j++)
   {
   let ind = offset + j;
   if(nonZeroData[ind])
    {
	band[j] = MDCTcoeffs[ind];
	continue;
	}
   band[j] = 0;
   }
  let bandFreq = subbandFreq * refineNow + baseFreq;
  let maxDiff = bandMaxes[refineNow] * allowedError(bitPercent, bandFreq) / 100;
  let result = optimizedQuant(band, bandMaxes[refineNow], idealAlloc[refineNow], maxDiff);
  let arrayInd = refineNow * bandSize;
  chosenFactors[refineNow] = result.factor;
  allocated[refineNow] = result.precision;
  included[refineNow] = result.notZeroed;
  for(let j=0; j<bandSize; j++)
   {
   quantized[arrayInd] = result.values[j];
   decoded[arrayInd++] = result.reconstructed[j];
   }
  let addedBits = result.used - usedPerBand[refineNow];
  usedBits += addedBits;
  distribute -= addedBits;
  }
 savedBits = distribute;
 subbands = lastSubband + 1;
 return {quantized, decoded, allocated, chosenFactors, included, subbands};
 }

function optimizedQuant(MDCTband, bandMax, maxBits, allowedError)
 {
 let quantized = new Array(bandSize);
 let decoded = new Array(bandSize);
 let usedBits = 0;
 let includedCoeffs = 0;
 for(let i=2; i<=maxBits; i++)
  {
  let maxStorable = (1 << (i - 1));
  let scaleBy = bandMax / maxStorable;
  let idealFactor = 1 / scaleBy;
  let tableIndex = Math.floor(Math.log10(idealFactor / 20000) / -0.2041199826559248);
  if(tableIndex < 0)
   {
   tableIndex = 0;
   }
  else if(tableIndex > 63)
   {
   tableIndex = 63;
   }
  let scf = scaleFactors[tableIndex];
  if(Math.round(bandMax * scf) > maxStorable && tableIndex < 63)
   {
   tableIndex++;
   scf = scaleFactors[tableIndex];
   }
  let invScf = scaleFactorsInv[tableIndex];
  let passed = true;
  let maxErr = 0;
  usedBits = 0;
  includedCoeffs = 0;
  for(let j=0; j<bandSize; j++)
   {
   let single = MDCTband[j];
   if(single == 0)
    {
	quantized[j] = 0;
	decoded[j] = 0;
	continue;
	}
   let scaled = Math.round(single * scf);
   let reconstruct = scaled * invScf;
   let error = Math.abs(reconstruct - single);
   quantized[j] = scaled;
   decoded[j] = reconstruct;
   if(scaled != 0)
    {
	usedBits += i;
    includedCoeffs++;
	}
   if(error > allowedError)
    {
	passed = false;
	if(error > maxErr)
	 {
	 maxErr = error;
	 }
	if(i < maxBits)
	 {
	 break;
	 }
	}
   }
  if(passed || i == maxBits)
   {
   return {values: quantized, reconstructed: decoded, precision: i, used: usedBits, notZeroed: includedCoeffs, factor: tableIndex};
   }
  }
 }

function add_dB(values, count)
 {
 let total = 0;
 for(let i=0; i<count; i++)
  {
  total += Math.pow(10, values[i] / 10);
  }
 return 10 * Math.log10(total);
 }

function nonMaskSize(magnitude, tonal)
 {
 for(let i=0; i<4; i++)
  {
  if(magnitude >= regionSteps[i])
   {
   return tonal ? regionSizesTonal[i] : regionSizesNoise[i];
   }
  }
 return 0;
 }

function coeffToBark(coeff, rate)
 {
 let frq = ((coeff + 1) / 1024) * rate;
 let result = Bark(frq);
 return result > 26 ? 26 : result;
 }
 
function barkToCoeff(bark, rate)
 {
 let fr = Freq(bark);
 if(fr > rate / 2)
  {
  fr = rate / 2;
  }
 let result = Math.round((fr * 1024) / rate - 1);
 if(result < 0)
  {
  result = 0;
  }
 else if(result > 511)
  {
  result = 511;
  }
 return result;
 }

function freqToCoeff(frq, rate)
 {
 let res = Math.round((frq * 1024) / rate - 1);
 return res > 511 ? 511 : res;
 }

function coeffToFreq(coeff, rate)
 {
 return (coeff + 1) / 1024 * rate;
 }

function hearingThreshold(coeff, rate)
 {
 let find = coeffToFreq(coeff, rate);
 if(find < 50)
  {
  return thresholds[0];
  }
 let ind = parseInt((find - 50) / 60 + 1);
 return ind > 335 ? thresholds[335] : thresholds[ind];
 }`;


const encoderString = `

let audioBuffer;
let channelSamples = 0;
let audioChannels = 0;
let dataWidth = 0;
let originalSize = 0;
let receivedMeta = [];
let addMeta = false;

self.onmessage = function(event)
 {
 let input = event.data;
 switch(input.type)
  {
  case "config":
   {
   let params = input.values;
   bitPercent = params.quality;
   samplingRate = params.rate;
   dataWidth = params.bitDepth;
   audioChannels = params.channels;
   dynamicRange = params.dynaRange;
   frequencyRange = params.freqRange;
   topBitLimit = params.upBitLim;
   bottomBitLimit = params.loBitLim;
   mostImportant = params.lowFreqRange;
   transientThreshold = params.transientSens;
   bandSize = params.subbandSize;
   keyframeGap = params.keyframeInt;
   adaptiveAllocation = params.adaptAlloc;
   originalSize = params.origSize;
   highStart = freqToCoeff(4000, samplingRate);
   highStop = freqToCoeff(20000, samplingRate);
   noiseFloor = noiseFloors[dataWidth];
   subbandFreq = samplingRate / 1024 * bandSize;
   lastLow = Math.floor(mostImportant / subbandFreq);
   regionSteps = [
	Math.round(dynamicRange * 0.84375),
	Math.round(dynamicRange * 0.73958),
	Math.round(dynamicRange * 0.63542),
	Math.round(dynamicRange * 0.47917)
	];
   receivedMeta = params.fileMetaData;
   addMeta = params.includeMeta;
   postMessage({type: "received"});
   }
  break;
  case "audio":
   {
   audioBuffer = new Int32Array(input.audio);
   channelSamples = input.chSamples;
   postMessage({type: "received"});
   }
  break;
  case "encode":
   {
   Encode(bitPercent);
   }
  break;
  case "slice":
   {
   let startTime = input.startFrom;
   let sliceDur = input.fragment;
   sliceAudio(startTime, sliceDur);
   }
  break;
  case "stop":
   {
   postMessage({type: "stopped", audio: audioBuffer}, [audioBuffer.buffer]);
   self.close();
   }
  break;
  }	 
 }


function Encode(quality)
 {
 let encoded = new Uint8Array(originalSize);
 let preview = new Uint8Array(originalSize);
 savedBits = 0;
 let frames = (channelSamples >> 9) - 1;
 if(frames < 1)
  {
  abortProcess("Error: too short file.");
  return;
  }
 let upperLim = tops[dataWidth];
 let bottomLim = bottoms[dataWidth];
 let setCutoff = frequencyRange == 0 ? cutoff(bitPercent) : frequencyRange;
 let usedBands = Math.ceil((freqToCoeff(setCutoff, samplingRate) + 1) / bandSize);
 let framesPerSecond = samplingRate / 512;
 let frameGroupSize = Math.round(framesPerSecond / 4);
 let groupMult = framesPerSecond / frameGroupSize * 8;
 let includedFrames = 0;
 let keyFrameInterval = Math.round(framesPerSecond * keyframeGap);
 let keyFramesCount = Math.floor((frames - 1) / (keyFrameInterval + 1)) + 1;
 let headerData = createHeader(keyFramesCount, keyFrameInterval, frames);
 let keyAllocPointer = headerData.headLen;
 for(let i=4; i<keyAllocPointer; i++)
  {
  encoded[i] = headerData.created[i];
  }
 let startBytePointer = headerData.size;
 let startByteOffset = 0;
 let allocData = [];
 let factorData = [];
 let transients = new Array(audioChannels).fill(false);
 let prevHighTones = new Array(audioChannels).fill(noiseFloor);
 let bitStream = [];
 let lenData = [];
 let subbandPointers = [];
 let previewPointer = 44;
 let overlapAdd = [];
 let prevSize = startBytePointer;
 for(let i=0; i<audioChannels; i++)
  {
  allocData.push(new Array(usedBands));
  factorData.push(new Array(usedBands));
  subbandPointers.push(new Array(usedBands));
  overlapAdd.push([new Array(512), new Array(1024)]);
  }
 let normalCount = keyFrameInterval;
 let percentBef = 1;
 for(let i=0; i<frames; i++)
  {
  let percentNow = Math.round(i / frames * 100);
  if(percentNow != percentBef)
   {
   postMessage({type: "progress", value: percentNow});
   percentBef = percentNow;
   }
  if(normalCount == keyFrameInterval)
   {
   for(let j=0; j<audioChannels; j++)
    {
    let keyFrame = createFrame(i, j, prevHighTones[j], transients[j]);
	
	transients[j] = keyFrame.transient;
	prevHighTones[j] = keyFrame.high;
	let singleAlloc = keyFrame.allocated;
    let singleFactor = keyFrame.chosenFactors;
    let frameBands = keyFrame.subbands;
    let quantizedFrame = keyFrame.quantized;
    let coefficients = frameBands * bandSize;
	let decodedAudio = FIMDCT(keyFrame.decoded, coefficients);
	if(i == 0)
	 {
	 overlapAdd[j][0] = decodedAudio.slice(0, 512);
	 }
	else
	 {
	 overlapAdd[j][0] = overlapAdd[j][1].slice(512, 1024);
	 }
	overlapAdd[j][1] = decodedAudio;
	let bitLen = 8;
    bitStream = [];
    lenData = [];
	if(j == 0)
	 {
	 if(startByteOffset)
	  {
	  startBytePointer++;
	  startByteOffset = 0;
	  }
	 let frameLoc = binConvert(startBytePointer, 4);
     for(let k=0; k<4; k++)
      {
      encoded[keyAllocPointer++] = frameLoc[k];
      }
     }
	bitStream.push(usedBands | 128);
    lenData.push(8);
	for(let k=0; k<usedBands; k++)
     {
     if(k >= frameBands)
      {
	  bitStream.push(0);
	  bitStream.push(0);
	  bitStream.push(0);
	  lenData.push(1);
      bitLen++;
      let bytesForward = (bitLen + startByteOffset) >> 3;
	  let bitAt = (bitLen + startByteOffset) & 7;
	  subbandPointers[j][k] = ((startBytePointer + bytesForward) << 3) + bitAt;
	  lenData.push(4);
      lenData.push(6);
      bitLen += 10;
	  allocData[j][k] = 255;
	  continue;
	  }
     let precision = singleAlloc[k];
     let inUse = precision != 0;
     if(inUse)
      {
	  bitStream.push(1);
	  bitStream.push(precision - 1);
	  bitStream.push(singleFactor[k]);
	  allocData[j][k] = precision;
	  factorData[j][k] = singleFactor[k];
	  }
     else
      {
	  bitStream.push(0);
	  bitStream.push(0);
	  bitStream.push(0);
	  allocData[j][k] = 255;
	  }
     lenData.push(1);
	 bitLen++;
     let bytesForward = (bitLen + startByteOffset) >> 3;
	 let bitAt = (bitLen + startByteOffset) & 7;
	 subbandPointers[j][k] = ((startBytePointer + bytesForward) << 3) + bitAt;
	 lenData.push(4);
     lenData.push(6);
     bitLen += 10;
     if(!inUse)
      {
	  continue;
	  }
     let quantOffset = k * bandSize;
     for(let l=0; l<bandSize; l++)
      {
	  let single = quantizedFrame[quantOffset++];
	  if(single == 0)
	   {
	   bitStream.push(0);
	   lenData.push(1);
	   bitLen++;
	   continue;
	   }
	  bitStream.push(1);
	  lenData.push(1);
	  if(single < 0)
	   {
	   single = -single;
	   bitStream.push(1);
	   }
	  else
	   {
	   bitStream.push(0);
	   }
	  lenData.push(1);
	  bitStream.push(single - 1);
	  lenData.push(precision - 1);
	  bitLen += precision + 1;
	  }
     }
    let usedBytes = Math.ceil((bitLen + startByteOffset) / 8);
    let formattedFrame = byteFormat(bitStream, lenData, usedBytes, startByteOffset);
    for(let k=0; k<usedBytes; k++)
     {
     if(k == 0 && startByteOffset)
	  {
	  encoded[startBytePointer++] |= formattedFrame[0];
	  continue;
	  }
	 encoded[startBytePointer++] = formattedFrame[k];
	 }
	startByteOffset = (bitLen + startByteOffset) & 7;
	if(startByteOffset){startBytePointer--;}
	}
   normalCount = 0;
   }
  else
   {
   for(let j=0; j<audioChannels; j++)
    {
	let normalFrame = createFrame(i, j, prevHighTones[j], transients[j]);
	transients[j] = normalFrame.transient;
	prevHighTones[j] = normalFrame.high;
    let singleAlloc = normalFrame.allocated;
    let singleFactor = normalFrame.chosenFactors;
    let frameBands = normalFrame.subbands;
    let quantizedFrame = normalFrame.quantized;
	let coefficients = frameBands * bandSize;
	let decodedAudio = FIMDCT(normalFrame.decoded, coefficients);
	overlapAdd[j][0] = overlapAdd[j][1].slice(512, 1024);
	overlapAdd[j][1] = decodedAudio;
	let allocDiff = [];
	let factorDiff = [];
	let isEmpty = [];
	let lastEmpty = -1;
	let emptyCount = 0;
	let maxEmpty = 0;
    let maxAllocDiff = 0;
	let maxFactorDiff = 0;
	let nonZeroAlloc = 0;
	let nonZeroFactor = 0;
	for(let k=0; k<frameBands; k++)
	 {
	 if(singleAlloc[k] == 0)
	  {
	  allocDiff.push(0);
	  factorDiff.push(0);
	  emptyCount++;
	  if(lastEmpty == -1)
	   {
	   isEmpty.push(1);
	   lastEmpty = k;
	   continue;
	   }
	  let counted = isEmpty[lastEmpty] + 1;
	  if(counted > maxEmpty)
	   {
	   maxEmpty = counted;
	   }
	  isEmpty[lastEmpty] = counted;
	  isEmpty.push(1);
	  continue;
	  }
	 isEmpty.push(0);
	 lastEmpty = -1;
	 if(allocData[j][k] == 255)
	  {
	  allocDiff.push(0);
	  factorDiff.push(0);
	  let updateByte = subbandPointers[j][k] >> 3;
	  let startBit = subbandPointers[j][k] - (updateByte << 3);
	  let change = Math.ceil((startBit + 10) / 8);
	  let modify = encoded.slice(updateByte, updateByte + change);
	  let subbandData = (((singleAlloc[k] - 1) << 6) | singleFactor[k]) & 1023;
	  modify = insert(modify, subbandData, 10, change, startBit);
	  for(let l=0; l<change; l++)
	   {
	   encoded[updateByte + l] = modify[l];
	   }
	  allocData[j][k] = singleAlloc[k];
	  factorData[j][k] = singleFactor[k];
	  continue;
	  }
	 let singleAllocDiff = singleAlloc[k] - allocData[j][k];
	 let singleFactorDiff = singleFactor[k] - factorData[j][k];
	 nonZeroAlloc += singleAllocDiff != 0;
	 nonZeroFactor += singleFactorDiff != 0;
	 let allocAbs = Math.abs(singleAllocDiff);
	 let factorAbs = Math.abs(singleFactorDiff);
	 if(allocAbs > maxAllocDiff)
	  {
	  maxAllocDiff = allocAbs;
	  }
	 if(factorAbs > maxFactorDiff)
	  {
	  maxFactorDiff = factorAbs;
	  }
	 allocDiff.push(singleAllocDiff);
	 factorDiff.push(singleFactorDiff);
	 allocData[j][k] = singleAlloc[k];
	 factorData[j][k] = singleFactor[k];
	 }
	let allocBits = 0;
	let factorBits = 0;
	let nonZeroBits = 0;
	if(maxAllocDiff != 0)
	 {
	 while(1 << allocBits <= maxAllocDiff)
	  {
	  allocBits++;
	  }
	 allocBits++;
	 nonZeroBits++;
	 }
	if(maxFactorDiff != 0)
	 {
	 while(1 << factorBits < maxFactorDiff)
	  {
	  factorBits++;
	  }
	 factorBits++;
	 nonZeroBits++;
	 }
	let bandsInUse = frameBands - emptyCount;
	let handleEmpty = 0;
	if(emptyCount)
	 {
	 let allocForNonEmpty = allocBits;
	 if(allocBits > 1)
	  {
	  allocForNonEmpty = 1 << (allocBits - 2) >= maxAllocDiff ? allocBits - 1 : allocBits;
	  }
	 let differentialBits = nonZeroFactor * factorBits;
	 let differentialBitsNonEmpty = differentialBits + nonZeroAlloc * allocForNonEmpty;
	 differentialBits += nonZeroAlloc * allocBits;
	 let bitsWithNonZero = frameBands + bandsInUse * (nonZeroBits + bandSize) + differentialBitsNonEmpty;
	 let bitsEmptyIncluded = frameBands * (nonZeroBits + bandSize) + differentialBits;
	 let adjAllocBits;
	 if(allocBits == 0)
	  {
	  adjAllocBits = 2;
	  }
	 else
	  {
	  adjAllocBits = (1 << (allocBits - 1)) >= maxAllocDiff + 1 ? allocBits : allocBits + 1;
	  }
	 let bitsEmptyMarked = bandsInUse * ((factorBits != 0) + bandSize + 1) + nonZeroAlloc * adjAllocBits + nonZeroFactor * factorBits + emptyCount * (adjAllocBits + 1);
	 let bitsEmptyGrouped = bitsEmptyIncluded + 1;
	 let adjFactorBits = factorBits == 0 ? 1 : factorBits;
	 while(1 << adjFactorBits <= maxEmpty - 2)
	  {
	  adjFactorBits++;
	  }
	 if(maxEmpty > 1)
	  {
	  bitsEmptyGrouped = nonZeroAlloc * adjAllocBits + nonZeroFactor * adjFactorBits + (bandSize + 2) * bandsInUse;
	  for(let k=0; k<frameBands; k++)
	   {
	   let subbandData = isEmpty[k];
	   if(subbandData == 0)
	    {
		continue;
		}
	   if(subbandData == 1)
	    {
		bitsEmptyGrouped += adjAllocBits + 1;
		continue;
		}
	   bitsEmptyGrouped += adjAllocBits + adjFactorBits + 2;
	   k += subbandData - 1;
	   }
	  }
	 let dataGrouped = [bitsEmptyIncluded, bitsWithNonZero, bitsEmptyGrouped, bitsEmptyMarked];
	 let numbered = [0, 1, 3, 2];
	 let chooseMin = new Array(4);
	 let methodNumbers = new Array(4);
	 for(let k=0; k<4; k++)
	  {
	  chooseMin[k] = dataGrouped[k];
	  methodNumbers[k] = numbered[k];
	  if(k == 0)
	   {
	   continue;
	   }
	  let l = k - 1;
	  while(l >= 0 && dataGrouped[k] < chooseMin[l])
	   {
	   chooseMin[l + 1] = chooseMin[l];
	   methodNumbers[l + 1] = methodNumbers[l];
	   l--;
	   }
	  chooseMin[l + 1] = dataGrouped[k];
	  methodNumbers[l + 1] = numbered[k];
	  }
	 handleEmpty = methodNumbers[0];
	 switch(handleEmpty)
	  {
	  case 1:
	   {
	   allocBits = allocForNonEmpty;
	   }
	  break;
	  case 2:
	   {
	   allocBits = adjAllocBits;
	   }
	  break;
	  case 3:
	   {
	   allocBits = adjAllocBits;
	   factorBits = adjFactorBits;
	   }
	  break;
	  }
	 }
	let bitLen = 15;
	bitStream = [];
    lenData = [];
	bitStream.push(frameBands);
	handleEmpty == 1 ? bitStream.push(1) : bitStream.push(0);
	bitStream.push(allocBits);
	bitStream.push(factorBits);
	lenData.push(8);
	lenData.push(1);
	lenData.push(3);
	lenData.push(3);
	for(let k=0; k<frameBands; k++)
	 {
	 let emptyData = isEmpty[k];
	 if(handleEmpty == 1)
	  {
	  lenData.push(1);
	  bitLen++;
	  if(emptyData)
	   {
	   bitStream.push(0);
	   continue;
	   }
	  bitStream.push(1);
	  }
	 if(emptyData)
	  {
	  switch(handleEmpty)
	   {
	   case 0:
	    {
	    if(nonZeroBits)
		 {
		 bitStream.push(0);
		 lenData.push(nonZeroBits);
		 bitLen += nonZeroBits;
		 }
		let zeroCount = bandSize;
		while(zeroCount > 0)
		 {
		 zeroCount -= 16;
		 let added = 16;
		 if(zeroCount < 0)
		  {
		  added += zeroCount;
		  zeroCount = 0;
		  }
		 bitStream.push(0);
		 lenData.push(added);
		 }
		bitLen += bandSize;
		}
	   break;
	   case 2:
	    {
	    let maxAllocVal = 1 << (allocBits - 1);
		bitStream.push(1);
		bitStream.push(0);
		bitStream.push(maxAllocVal - 1);
		lenData.push(1);
		lenData.push(1);
		lenData.push(allocBits - 1);
		bitLen += allocBits + 1;
	    }
	   break;
	   case 3:
	    {
	    let maxAllocVal = 1 << (allocBits - 1);
		bitStream.push(1);
		emptyData == 1 ? bitStream.push(0) : bitStream.push(1);
		bitStream.push(maxAllocVal - 1);
		lenData.push(1);
		lenData.push(1);
		lenData.push(allocBits - 1);
		bitLen += allocBits + 1;
		if(emptyData == 1)
		 {
		 continue;
		 }
		bitStream.push(emptyData - 2);
		lenData.push(factorBits + 1);
		bitLen += factorBits + 1;
		k += emptyData - 1;
		}
	   break;
	   }
	  continue;
	  }
	 if(allocBits != 0)
	  {
	  let singleDiff = allocDiff[k];
	  if(singleDiff == 0)
	   {
	   bitStream.push(0);
	   lenData.push(1);
	   bitLen++;
	   }
	  else
	   {
	   bitStream.push(1);
	   lenData.push(1);
	   if(singleDiff < 0)
	    {
		singleDiff = -singleDiff;
		bitStream.push(1);
		}
	   else
	    {
		bitStream.push(0);
		}
	   lenData.push(1);
	   let remain = allocBits - 1;
	   if(remain > 0)
	    {
		bitStream.push(singleDiff - 1);
		lenData.push(remain);
		}
	   bitLen += remain + 2;
	   }
	  }
	 if(factorBits != 0)
	  {
	  let singleDiff = factorDiff[k];
	  if(singleDiff == 0)
	   {
	   bitStream.push(0);
	   lenData.push(1);
	   bitLen++;
	   }
	  else
	   {
	   bitStream.push(1);
	   lenData.push(1);
	   if(singleDiff < 0)
	    {
		singleDiff = -singleDiff;
		bitStream.push(1);
		}
	   else
	    {
		bitStream.push(0);
		}
	   lenData.push(1);
	   let remain = factorBits - 1;
	   if(remain > 0)
	    {
		bitStream.push(singleDiff - 1);
		lenData.push(remain);
		}
	   bitLen += remain + 2;
	   }
	  }
	 let quantOffset = k * bandSize;
     for(let l=0; l<bandSize; l++)
      {
	  let single = quantizedFrame[quantOffset++];
	  if(single == 0)
	   {
	   bitStream.push(0);
	   lenData.push(1);
	   bitLen++;
	   continue;
	   }
	  bitStream.push(1);
	  lenData.push(1);
	  if(single < 0)
	   {
	   single = -single;
	   bitStream.push(1);
	   }
	  else
	   {
	   bitStream.push(0);
	   }
	  let precision = singleAlloc[k];
	  lenData.push(1);
	  bitStream.push(single - 1);
	  lenData.push(precision - 1);
	  bitLen += precision + 1;
	  }
	 }
	let usedBytes = Math.ceil((bitLen + startByteOffset) / 8);
	let formattedFrame = byteFormat(bitStream, lenData, usedBytes, startByteOffset);
	for(let k=0; k<usedBytes; k++)
     {
     if(k == 0 && startByteOffset)
	  {
	  encoded[startBytePointer++] |= formattedFrame[0];
	  continue;
	  }
	 encoded[startBytePointer++] = formattedFrame[k];
     }
	startByteOffset = (bitLen + startByteOffset) & 7;
	if(startByteOffset){startBytePointer--;}
	}
   normalCount++;
   }
  if(startBytePointer > originalSize)
   {
   abortProcess("Error: data overflow.");
   return;
   }
  includedFrames++;
  if(includedFrames >= frameGroupSize)
   {
   includedFrames = 0;
   let increasedBy = startBytePointer - prevSize;
   let estimatedBitrate = increasedBy * groupMult;
   prevSize = startBytePointer;
   postMessage({type: "bitrate", value: estimatedBitrate});
   }
  if(i == 0)
   {
   for(let j=0; j<512; j++)
	{
	for(let k=0; k<audioChannels; k++)
	 {
	 let single = overlapAdd[k][0][j];
	 if(single > upperLim)
	  {
	  single = upperLim;
	  }
	 else if(single < bottomLim)
	  {
	  single = bottomLim;
	  }
	 let bytes = binConvert(single, dataWidth);
	 for(let val of bytes)
	  {
	  preview[previewPointer++] = val;
	  }
	 }
	}
   continue;
   }
  for(let j=0; j<512; j++)
   {
   for(let k=0; k<audioChannels; k++)
	{
	let single = overlapAdd[k][0][j] + overlapAdd[k][1][j];
	if(single > upperLim)
	 {
	 single = upperLim;
	 }
	else if(single < bottomLim)
	 {
	 single = bottomLim;
	 }
	let bytes = binConvert(single, dataWidth);
	for(let val of bytes)
	 {
	 preview[previewPointer++] = val;
	 }
	}
   }
  }
 let remaining = originalSize - previewPointer;
 let addByte = dataWidth == 1 ? 127 : 0;
 for(let i=0; i<remaining; i++)
  {
  preview[previewPointer++] = addByte;
  }
 const header = [82, 73, 70, 70, 87, 65, 86, 69, 102, 109, 116, 32, 100, 97, 116, 97];
 const indexes = [0, 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15, 36, 37, 38, 39];
 let readPointer = 0;
 for(let i of indexes)
  {
  preview[i] = header[readPointer++];
  }
 let previewSize = binConvert(previewPointer - 8, 4);
 for(let i=0; i<4; i++)
  {
  preview[i + 4] = previewSize[i];
  }
 preview[16] = 16;
 preview[20] = 1;
 preview[22] = audioChannels;
 preview[23] = audioChannels >> 8;
 let rateInfo = binConvert(samplingRate, 4);
 for(let i=0; i<4; i++)
  {
  preview[i + 24] = rateInfo[i];
  }
 let dataVerify1 = binConvert(samplingRate * audioChannels * dataWidth, 4);
 for(let i=0; i<4; i++)
  {
  preview[i + 28] = dataVerify1[i];
  }
 let dataVerify2 = binConvert(audioChannels * dataWidth, 2);
 preview[32] = dataVerify2[0];
 preview[33] = dataVerify2[1];
 preview[34] = dataWidth << 3;
 let audioSection = binConvert(previewPointer - 44, 4);
 for(let i=0; i<4; i++)
  {
  preview[i + 40] = audioSection[i];
  }
 let totalSize = startByteOffset ? startBytePointer + 1 : startBytePointer;
 let store = binConvert(totalSize, 4);
 for(let i=0; i<4; i++)
  {
  encoded[i] = store[i];
  }
 let duration = (frames + 1) * 512 / samplingRate;
 let compressionRatio = (originalSize / totalSize).toFixed(2);
 let avgBitrate = (totalSize / duration * 0.008).toFixed(2);
 let trimmedFile = encoded.slice(0, totalSize);
 postMessage({type: "terminated", audio: audioBuffer.buffer, compressed: trimmedFile.buffer, wavePreview: preview.buffer, bitrate: avgBitrate, ratio: compressionRatio, size: totalSize}, [audioBuffer.buffer, trimmedFile.buffer, preview.buffer]);
 self.close();
 }

function sliceAudio(startTime, fragDur)
 {
 let totalFrames = (channelSamples >> 9) - 1;
 if(totalFrames < 1)
  {
  abortProcess("Error: too short file.");
  return;
  }
 let upperLim = tops[dataWidth];
 let bottomLim = bottoms[dataWidth];
 let normFactor = normalizeFactors[dataWidth];
 let firstSample = Math.round(startTime * samplingRate);
 let lastSample = Math.round((startTime + fragDur) * samplingRate);
 let totalSamples = lastSample - firstSample;
 let startFrame = Math.floor(firstSample / 512 - 1);
 let endFrame = Math.floor(lastSample / 512);
 let startOffset = firstSample & 511;
 let endOffset = lastSample & 511;
 let endTime = lastSample / samplingRate;
 let actualDur = totalSamples / samplingRate;
 let usedChannels = audioChannels > 1 ? 2 : 1;
 let transients = [false, false];
 let prevHighTones = [-1, -1];
 let overlapAdd = [[new Array(512), new Array(1024)], [new Array(512), new Array(1024)]];
 let slicedSamples = [new Float32Array(totalSamples), new Float32Array(totalSamples)];
 let slicePointers = [0, 0];
 let estimatedSize = 0;
 if(startFrame < 0)
  {
  startFrame = 0;
  }
 let readSamples = (endFrame - startFrame + 1) * 512;
 for(let i=startFrame; i<=endFrame; i++)
  {
  for(let j=0; j<usedChannels; j++)
   {
   let created = createFrame(i, j, prevHighTones[j], transients[j]);
   prevHighTones[j] = created.high;
   transients[j] = created.transient;
   let frameSize = 15 + created.subbands;
   for(let k=0; k<created.subbands; k++)
    {
	let precision = created.allocated[k];
	if(precision == 0)
	 {
	 continue;
	 }
	frameSize += 3 + bandSize;
	frameSize += created.included[k] * precision;
	}
   estimatedSize += frameSize;
   let rawAudio = FIMDCT(created.decoded, created.subbands * bandSize);
   if(i == startFrame)
	{
	overlapAdd[j][0] = rawAudio.slice(0, 512);
	overlapAdd[j][1] = rawAudio;
	continue;
	}
   overlapAdd[j][0] = overlapAdd[j][1].slice(512, 1024);
   overlapAdd[j][1] = rawAudio;
   for(let k=0; k<512; k++)
	{
	if(i == endFrame && k >= endOffset)
	 {
	 break;
	 }
	if(i == startFrame + 1 && k < startOffset)
	 {
	 continue;
	 }
	let normalized = overlapAdd[j][0][k] + overlapAdd[j][1][k];
	if(normalized > upperLim)
	 {
	 normalized = upperLim;
	 }
	else if(normalized < bottomLim)
	 {
	 normalized = bottomLim;
	 }
	if(dataWidth == 1){normalized -= 128;}
	normalized /= normFactor;
	slicedSamples[j][slicePointers[j]++] = normalized;
	}
   }
  }
 let estimatedBitrate = estimatedSize * (samplingRate / readSamples);
 if(usedChannels == 2)
  {
  postMessage({type: "success", audioL: slicedSamples[0], audioR: slicedSamples[1], sampleLen: slicePointers[0], endStamp: endTime, duration: actualDur, avgBitrate: estimatedBitrate}, [slicedSamples[0].buffer, slicedSamples[1].buffer]);
  return;
  }
 postMessage({type: "success", audioL: slicedSamples[0], sampleLen: slicePointers[0], endStamp: endTime, duration: actualDur, avgBitrate: estimatedBitrate}, [slicedSamples[0].buffer]);
 }

function abortProcess(messageText)
 {
 postMessage({type: "error", desc: messageText, audio: audioBuffer.buffer}, [audioBuffer.buffer]);
 self.close();
 }

function createHeader(keyFrameCount, keyFrameSpacing, frameCount)
 {
 let samplingData = samplingRate;
 let totalKeyFrames = keyFrameCount;
 let header = new Array(21).fill(0);
 let headerPointer = 4;
 for(let i=0; i<4; i++)
  {
  header[headerPointer++] = frameCount & 255;
  frameCount >>= 8;
  }
 header[headerPointer++] = dataWidth & 255;
 header[headerPointer++] = bandSize & 255;
 header[headerPointer++] = (audioChannels - 1) & 255;
 for(let i=0; i<3; i++)
  {
  header[headerPointer++] = samplingData & 255;
  samplingData >>= 8;
  }
 for(let i=0; i<3; i++)
  {
  header[headerPointer++] = keyFrameCount & 255;
  keyFrameCount >>= 8;
  }
 header[headerPointer++] = keyFrameSpacing & 255;
 header[headerPointer++] = (keyFrameSpacing >> 8) & 255;
 headerPointer += 2;
 if(addMeta)
  {
  const prefixes = ["TI", "AR", "AL", "GE", "YE", "TR"];
  for(let i=0; i<6; i++)
   {
   let single = receivedMeta[i];
   let characters = single.length;
   if(characters > 0)
    {
	if(characters > 254)
	 {
	 characters = 254;
	 }
	header.push(prefixes[i].charCodeAt(0));
	header.push(prefixes[i].charCodeAt(1));
	header.push(characters + 1);
	headerPointer += 3;
	for(let j=0; j<characters; j++)
	 {
	 let code = single.charCodeAt(j);
	 header.push(code & 255);
	 header.push((code >> 8) & 255);
	 headerPointer += 2;
	 }
	header.push(0);
	header.push(0);
	headerPointer += 2;
	}
   }
  header[19] = headerPointer & 255;
  header[20] = (headerPointer >> 8) & 255;
  }
 let headerBytes = headerPointer + totalKeyFrames * 4;
 let packed = new Uint8Array(header);
 return {created: packed, size: headerBytes, headLen: headerPointer};
 }`;


const waveLoaderString = `

self.onmessage = function(event)
 {
 let fileData = event.data;
 let contents = new Uint8Array(fileData.raw);
 let extension = fileData.type;
 function sliceValues(lenData, sliceModes, startByte, bitAt, count)
  {
  let read = [];
  let sliceFrom = contents;
  for(let i=0; i<count; i++)
   {
   let len = lenData[i];
   if(len == 0)
    {
	read.push(0);
    continue;
	}
   let complexSlice = sliceModes[i];
   if(complexSlice)
    {
    let nonZero = sliceFrom[startByte] & (1 << (7 - bitAt));
    bitAt++;
    if(bitAt == 8)
     {
     bitAt = 0;
     startByte++;
     }
    if(!nonZero)
     {
     read.push(0);
     continue;
     }
    }
   let bytes = (bitAt + len + 7) >> 3;
   let sliced = 0;
   let adjust = (bytes << 3) - len - bitAt;
   if(bytes == 1)
    {
    sliced = (sliceFrom[startByte] >> adjust) & ((1 << len) - 1);
    }
   else
    {
    sliced |= sliceFrom[startByte] & (255 >> bitAt);
    if(bytes == 2)
     {
     sliced <<= 8 - adjust;
     sliced |= sliceFrom[startByte + 1] >> adjust;
     }
    else
     {
     sliced <<= 8;
     sliced |= sliceFrom[startByte + 1];
     sliced <<= 8 - adjust;
     sliced |= sliceFrom[startByte + 2] >> adjust;
     }
    }
   if(complexSlice)
    {
    let signCheck = 1 << (len - 1);
    let sign = sliced & signCheck;
    sliced++;
    if(sign)
     {
     sliced = -sliced + signCheck;
     }
    }
   read.push(sliced);
   bitAt += len;
   startByte += bitAt >> 3;
   bitAt &= 7;
   }
  return {values: read, bytePos: startByte, bitPos: bitAt};
  }
 switch(extension)
  {
  case "wav":
   {
   const header = [82, 73, 70, 70, 87, 65, 86, 69, 102, 109, 116, 32, 100, 97, 116, 97];
   const indexes = [0, 1, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15, 36, 37, 38, 39];
   let pointer = 0;
   for(let i of indexes)
    {
    if(contents[i] != header[pointer++])
     {
     postMessage({type: "error", desc: "File is corrupted"});
     return;
     }
    }
   let totalSize = contents[7];
   for(let i=0; i<3; i++)
    {
    totalSize <<= 8;
    totalSize |= contents[6 - i];
    }
   totalSize += 8;
   let channels = (contents[23] << 8) | contents[22];
   let sampling = (contents[26] << 16) | (contents[25] << 8) | contents[24];
   let dataSize = contents[34];
   let dataSectionSize = contents[43];
   for(let i=0; i<3; i++)
    {
    dataSectionSize <<= 8;
    dataSectionSize |= contents[42 - i];
    }
   if(totalSize > 1073741824 || dataSectionSize > 1073741780)
    {
    postMessage({type: "error", desc: "Size over limit (1GB)"});
    return;
    }
   let validSizes = [8, 16, 24];
   if(channels < 1 || channels > 256 || validSizes.indexOf(dataSize) == -1 || sampling < 1000 || sampling > 1000000)
    {
    postMessage({type: "error", desc: "Invalid audio parameters"});
    return;
    }
   dataSize /= 8;
   let totalSamples = parseInt(dataSectionSize / dataSize);
   let points = parseInt(totalSamples / channels);
   let samplePointer = 44;
   let bufferPointer = 0;
   let firstBit = 1 << (dataSize * 8 - 1);
   let audioBuffer = new Int32Array(totalSamples);
   for(let i=0; i<points; i++)
    {
    for(let j=0; j<channels; j++)
     {
     let single = contents[samplePointer + dataSize - 1];
     for(let k=dataSize-2; k>=0; k--)
	  {
	  single <<= 8;
	  single |= contents[samplePointer + k];
	  }
     if(dataSize > 1)
	  {
	  single -= (single & firstBit) << 1;
      }
     audioBuffer[bufferPointer++] = single;
     samplePointer += dataSize;
     }
    }
   let byteLen = contents.length;
   const find = [76, 73, 83, 84];
   let metaFound = false;
   for(let i=0; i<256; i++)
    {
    if(samplePointer + 4 > byteLen)
     {
     break;
     }
    for(let j=0; i<4; j++)
     {
     if(contents[samplePointer + j] != find[j])
      {
	  break;
	  }
     if(j == 3 && samplePointer < byteLen - 21)
      {
	  metaFound = true;
	  }
     }
    if(metaFound)
     {
     samplePointer += 4;
     break;
     }
    samplePointer++;
    }
   let metaContent = new Array(6).fill("");
   if(metaFound)
    {
    let metaLen = contents[samplePointer + 1];
    metaLen <<= 8;
    metaLen |= contents[samplePointer];
    samplePointer += 4;
    let metaEnd = samplePointer + metaLen;
    if(metaEnd > byteLen)
     {
     metaEnd = byteLen;
     metaLen = metaEnd - samplePointer;
     }
    samplePointer += 4;
    const templates = ["INAM", "IART", "IPRD", "IGNR", "ICRD", "ITRK"];
    for(let i=4; i<metaLen; i++)
     {
     let single = "";
     if(i + 8 > metaLen)
      {
	  break;
	  }
     for(let j=0; j<4; j++)
      {
      single += String.fromCharCode(contents[samplePointer++]);
      }
     let singleLen = contents[samplePointer];
     samplePointer += 4;
     i += 8;
     if(i + singleLen > metaLen)
      {
	  break;
	  }
     let property = templates.indexOf(single);
     if(property != -1)
      {
	  let read = "";
	  for(let j=0; j<singleLen; j++)
	   {
	   let readChar = contents[samplePointer + j];
	   if(readChar == 0)
	    {
	    break;
	    }
	   if(readChar > 31 && readChar < 127)
	    {
	    read += String.fromCharCode(readChar);
	    continue;
	    }
	   read += "_";
	   }
	  metaContent[property] = read;
	  }
     i += singleLen - 1;
     samplePointer += singleLen;
     }
    }
   let duration = points / sampling;
   let fileData = {type: "success", audio: audioBuffer.buffer, metaData: metaContent, config: {dSize: dataSize, audioCh: channels, sRate: sampling, tSize: totalSize, sPerCh: points, len: duration}};
   postMessage(fileData, [audioBuffer.buffer]);
   }
  break;
  case "dac":
   {
   let byteSize = contents.length;
   if(byteSize < 20)
    {
    postMessage({type: "error", desc: "Too short file"});
    return;
    }
   if(byteSize > 1073741824)
    {
    postMessage({type: "error", desc: "Size over limit (1GB)"});
    return;
    }
   let totalFileSize = contents[3];
   for(let i=2; i>=0; i--)
    {
    totalFileSize <<= 8;
    totalFileSize |= contents[i];
    }
   if(totalFileSize > byteSize)
    {
    postMessage({type: "error", desc: "File size mismatch"});
    return;
    }
   let framesPerCh = contents[7];
   for(let i=6; i>=4; i--)
    {
    framesPerCh <<= 8;
    framesPerCh |= contents[i];
    }
   if(framesPerCh == 0)
    {
    postMessage({type: "error", desc: "File is corrupted"});
    return;
    }
   let dataWidth = contents[8];
   if(dataWidth < 1 || dataWidth > 3)
    {
    postMessage({type: "error", desc: "Unsupported bit depth"});
    return;
    }
   let subbandSize = contents[9];
   for(let i=4; i<64; i*=2)
    {
    if(subbandSize == i)
     {
     break;
     }
    if(i == 32)
     {
     postMessage({type: "error", desc: "Invalid subband size"});
     return;
     }
    }
   let channels = contents[10] + 1;
   let samplingRate = contents[13];
   for(let i=12; i>=11; i--)
    {
    samplingRate <<= 8;
    samplingRate |= contents[i];
    }
   if(samplingRate < 1000 || samplingRate > 1000000)
    {
    postMessage({type: "error", desc: "Invalid sampling rate"});
    return;
    }
   let keyFramesPerCh = contents[16];
   for(let i=15; i>=14; i--)
    {
    keyFramesPerCh <<= 8;
    keyFramesPerCh |= contents[i];
    }
   if(keyFramesPerCh == 0)
    {
    postMessage({type: "error", desc: "File is corrupted"});
    return;
    }
   let keyFrameInterval = contents[18];
   keyFrameInterval <<= 8;
   keyFrameInterval |= contents[17];
   if(keyFrameInterval == 0)
    {
    postMessage({type: "error", desc: "Invalid key frame spacing"});
    return;
    }
   let metaEndPointer = contents[20];
   metaEndPointer <<= 8;
   metaEndPointer |= contents[19];
   let metaContent = new Array(6).fill("");
   if(metaEndPointer > 25)
    {
	const templates = ["TI", "AR", "AL", "GE", "YE", "TR"];
	let metaPointer = 21;
	while(metaPointer < metaEndPointer)
	 {
	 let prefix = String.fromCharCode(contents[metaPointer]) + String.fromCharCode(contents[metaPointer + 1]);
	 metaPointer += 2;
	 let stringLen = contents[metaPointer++];
	 let metaType = templates.indexOf(prefix);
	 if(metaType != -1)
	  {
	  let single = "";
	  for(let i=0; i<stringLen; i++)
	   {
	   let chrCode = (contents[metaPointer + 1] << 8) | contents[metaPointer];
	   metaPointer += 2;
	   if(chrCode == 0)
	    {
		break;
		}
	   single += String.fromCharCode(chrCode);
	   }
	  metaContent[metaType] = single;
	  continue;
	  }
	 metaPointer += stringLen * 2;
	 }
	}
   let points = framesPerCh * 512;
   let totalSamples = points * channels;
   let totalWaveSize = totalSamples * dataWidth + 44;
   let duration = points / samplingRate;
   let audioBuffer = new Int32Array(totalSamples);
   let keyFramePointers = new Array(keyFramesPerCh);
   let keyFrameCount = 0;
   let dataPointer = metaEndPointer;
   let dataBit = 0;
   let outputPointer = 0;
   let upperLim = tops[dataWidth];
   let bottomLim = bottoms[dataWidth];
   for(let i=0; i<keyFramesPerCh; i++)
    {
    let pointer = contents[dataPointer + 3];
    for(let j=2; j>=0; j--)
     {
     pointer <<= 8;
     pointer |= contents[dataPointer + j];
     }
    keyFramePointers[i] = pointer;
	dataPointer += 4;
	}
   let normalCount = keyFrameInterval;
   let referenceAlloc = [];
   let referenceFactor = [];
   let overlapAdd = [];
   let subbandCount = parseInt(512 / subbandSize);
   for(let i=0; i<channels; i++)
    {
	referenceAlloc.push(new Array(subbandCount));
	referenceFactor.push(new Array(subbandCount));
	overlapAdd.push([new Array(512), new Array(1024)]);
	}
   for(let i=0; i<framesPerCh; i++)
    {
    if(normalCount == keyFrameInterval)
     {
     let frameLoc = keyFramePointers[keyFrameCount++];
	 if(frameLoc > metaEndPointer && frameLoc < byteSize)
	  {
	  dataPointer = frameLoc;
	  dataBit = 0;
	  }
	 for(let j=0; j<channels; j++)
      {
	  let frameBuffer = [];
	  let decodeResult = sliceValues([1, 7], [false, false], dataPointer, dataBit, 2);
	  let frameBands = decodeResult.values[1];
	  if(frameBands > subbandCount)
	   {
	   frameBands = subbandCount;
	   }
	  let frameCoeffs = frameBands * subbandSize;
	  dataPointer = decodeResult.bytePos;
	  dataBit = decodeResult.bitPos;
	  for(let k=0; k<frameBands; k++)
	   {
	   decodeResult = sliceValues([1, 4, 6], [false, false, false], dataPointer, dataBit, 3);
	   let absAlloc = decodeResult.values[1] + 1;
	   let absFactor = decodeResult.values[2];
	   dataPointer = decodeResult.bytePos;
	   dataBit = decodeResult.bitPos;
	   referenceAlloc[j][k] = absAlloc;
	   referenceFactor[j][k] = absFactor;
	   if(decodeResult.values[0])
	    {
		let lenData = new Array(subbandSize).fill(absAlloc);
		let sliceModes = new Array(subbandSize).fill(true);
		decodeResult = sliceValues(lenData, sliceModes, dataPointer, dataBit, subbandSize);
		dataPointer = decodeResult.bytePos;
	    dataBit = decodeResult.bitPos;
		for(let l=0; l<subbandSize; l++)
		 {
		 frameBuffer.push(decodeResult.values[l] * scaleFactorsInv[absFactor]);
		 }
		continue;
		}
	   for(let l=0; l<subbandSize; l++)
		{
		frameBuffer.push(0);
		}
	   }
	  let decodedAudio = FIMDCT(frameBuffer, frameCoeffs);
	  if(i == 0)
	   {
	   overlapAdd[j][0] = decodedAudio.slice(0, 512);
	   }
	  else
	   {
	   overlapAdd[j][0] = overlapAdd[j][1].slice(512, 1024);
	   }
	  overlapAdd[j][1] = decodedAudio;
	  }
     normalCount = 0;
     }
    else
     {
     for(let j=0; j<channels; j++)
      {
	  let frameBuffer = [];
	  let decodeResult = sliceValues([1, 7, 1, 3, 3], [false, false, false, false, false], dataPointer, dataBit, 5);
	  let frameBands = decodeResult.values[1];
	  let nonEmptyUsed = decodeResult.values[2];
	  let allocPrec = decodeResult.values[3];
	  let factorPrec = decodeResult.values[4];
	  if(allocPrec > 5)
	   {
	   allocPrec = 5;
	   }
	  if(frameBands > subbandCount)
	   {
	   frameBands = subbandCount;
	   }
	  let frameCoeffs = frameBands * subbandSize;
	  dataPointer = decodeResult.bytePos;
	  dataBit = decodeResult.bitPos;
	  if(nonEmptyUsed)
	   {
	   for(let k=0; k<frameBands; k++)
	    {
		if(contents[dataPointer] & (1 << (7 - dataBit)))
	     {
		 decodeResult = sliceValues([1, allocPrec, factorPrec], [false, true, true], dataPointer, dataBit, 3);
		 dataPointer = decodeResult.bytePos;
	     dataBit = decodeResult.bitPos;
		 let absAlloc = referenceAlloc[j][k] + decodeResult.values[1];
		 let absFactor = referenceFactor[j][k] + decodeResult.values[2];
		 if(absAlloc < 2 || absAlloc > 16)
		  {
		  absAlloc = referenceAlloc[j][k];
		  }
		 else
		  {
		  referenceAlloc[j][k] = absAlloc;
		  }
		 if(absFactor < 0 || absFactor > 63)
		  {
		  absFactor = referenceFactor[j][k];
		  }
		 else
		  {
		  referenceFactor[j][k] = absFactor;
		  }
		 let lenData = new Array(subbandSize).fill(absAlloc);
		 let sliceModes = new Array(subbandSize).fill(true);
		 decodeResult = sliceValues(lenData, sliceModes, dataPointer, dataBit, subbandSize);
		 dataPointer = decodeResult.bytePos;
	     dataBit = decodeResult.bitPos;
		 for(let l=0; l<subbandSize; l++)
		  {
		  frameBuffer.push(decodeResult.values[l] * scaleFactorsInv[absFactor]);
		  }
		 continue;
		 }
		dataBit++;
		dataPointer += dataBit >> 3;
		dataBit &= 7;
		for(let l=0; l<subbandSize; l++)
		 {
		 frameBuffer.push(0);
		 }
		}
	   }
	  else
	   {
	   for(let k=0; k<frameBands; k++)
	    {
	    decodeResult = sliceValues([allocPrec], [true], dataPointer, dataBit, 1);
	    dataPointer = decodeResult.bytePos;
	    dataBit = decodeResult.bitPos;
	    let diffAlloc = decodeResult.values[0];
	    if(allocPrec > 1)
	     {
	     let topAlloc = 1 << (allocPrec - 1);
	     let bottomAlloc = -topAlloc;
		 if(diffAlloc == topAlloc)
	      {
		  for(let l=0; l<subbandSize; l++)
		   {
		   frameBuffer.push(0);
		   }
		  continue;
		  }
	     if(diffAlloc == bottomAlloc)
	      {
		  decodeResult = sliceValues([factorPrec + 1], [false], dataPointer, dataBit, 1);
		  dataPointer = decodeResult.bytePos;
	      dataBit = decodeResult.bitPos;
		  let emptySubbands = decodeResult.values[0] + 2;
		  let zeroes = subbandSize * emptySubbands;
		  for(let l=0; l<zeroes; l++)
		   {
		   frameBuffer.push(0);
		   }
		  k += emptySubbands - 1;
		  continue;
		  }
	     }
	    decodeResult = sliceValues([factorPrec], [true], dataPointer, dataBit, 1);
	    dataPointer = decodeResult.bytePos;
	    dataBit = decodeResult.bitPos;
	    let absAlloc = referenceAlloc[j][k] + diffAlloc;
	    let absFactor = referenceFactor[j][k] + decodeResult.values[0];
	    if(absAlloc < 2 || absAlloc > 16)
		 {
		 absAlloc = referenceAlloc[j][k];
		 }
		else
		 {
		 referenceAlloc[j][k] = absAlloc;
		 }
		if(absFactor < 0 || absFactor > 63)
		 {
		 absFactor = referenceFactor[j][k];
		 }
		else
		 {
		 referenceFactor[j][k] = absFactor;
		 }
        let lenData = new Array(subbandSize).fill(absAlloc);
	    let sliceModes = new Array(subbandSize).fill(true);
	    decodeResult = sliceValues(lenData, sliceModes, dataPointer, dataBit, subbandSize);
	    dataPointer = decodeResult.bytePos;
	    dataBit = decodeResult.bitPos;
	    for(let l=0; l<subbandSize; l++)
		 {
		 frameBuffer.push(decodeResult.values[l] * scaleFactorsInv[absFactor]);
		 }
	    }
	   }
	  let decodedAudio = FIMDCT(frameBuffer, frameCoeffs);
	  overlapAdd[j][0] = overlapAdd[j][1].slice(512, 1024);
	  overlapAdd[j][1] = decodedAudio;
	  }
     normalCount++;
     }
    if(i == 0)
     {
     for(let j=0; j<512; j++)
	  {
	  for(let k=0; k<channels; k++)
	   {
	   let single = overlapAdd[k][0][j];
	   if(single > upperLim)
	    {
	    single = upperLim;
	    }
	   else if(single < bottomLim)
	    {
	    single = bottomLim;
	    }
	   audioBuffer[outputPointer++] = single;
	   }
	  }
     continue;
     }
    for(let j=0; j<512; j++)
     {
     for(let k=0; k<channels; k++)
	  {
	  let single = overlapAdd[k][0][j] + overlapAdd[k][1][j];
	  if(single > upperLim)
	   {
	   single = upperLim;
	   }
	  else if(single < bottomLim)
	   {
	   single = bottomLim;
	   }
	  audioBuffer[outputPointer++] = single;
	  }
     }
	}
   let fileData = {type: "success", audio: audioBuffer.buffer, metaData: metaContent, config: {dSize: dataWidth, audioCh: channels, sRate: samplingRate, tSize: totalWaveSize, sPerCh: points, len: duration}};
   postMessage(fileData, [audioBuffer.buffer]);
   }
  break;
  default:
   {
   postMessage({type: "error", desc: "Unsupported file format"});
   return;
   }
  break;
  }
 }`;


let audioBuffer;
let encodedBuffer;
let decodedBuffer;
let sampleRate = 0;
let audioChannels = 0;
let channelSamples = 0;
let dataWidth = 0;
let waveSize = 0;
let audioDuration = 0;
let loadedName = "";
let wasLoaded = false;
let wasEncoded = false;
let busyLoading = false;
let busyEncoding = false;
let busyPreview = false;
let encoder;
let parser;
let loader;
let haltTimeout;
let prevListener1;
let prevListener2;
let monitorRefresh = 0.15;


const mainPart1 = new Blob([lookupString], {type: "application/javascript"});
const mainPart2 = new Blob([coreFunctionString], {type: "application/javascript"});
const mainPart3 = new Blob([encoderString], {type: "application/javascript"});
const mainPart4 = new Blob([waveLoaderString], {type: "application/javascript"});
const fileEncoder = URL.createObjectURL(new Blob([mainPart1, mainPart2, mainPart3], {type: "application/javascript"}));
const waveLoader = URL.createObjectURL(new Blob([mainPart1, mainPart4], {type: "application/javascript"}));

window.addEventListener('pageshow', function(event)
 {
 retreiveEncodingParams(false);
 });

function id(what)
 {
 return document.getElementById(what);
 }

function run()
 {
 id("loadNew").addEventListener("click", function()
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  id("sound").click();
  });
 const sliderIDs = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 for(let i=0; i<6; i++)
  {
  let currID = sliderIDs[i];
  id(currID).addEventListener("input", function()
   {
   getPreset(i, true);
   });
  id(currID).addEventListener("mousewheel", function(event)
   {
   let dec = event.deltaY > 0;
   if(isBorder(i, dec))
    {
	return;
	}
   let now = rawVal(i);
   let step = i == 5 ? 0.05 : 1;
   dec ? now -= step : now += step;
   this.value = now;
   getPreset(i, true);
   }, {passive: true});
  }
 id("enc").addEventListener("click", function()
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  if(!wasLoaded)
   {
   fileInfo("No file provided.", 4000, "#fff", "No file loaded...", "#777");
   return;
   }
  encodeAudio();
  });
 id("play").addEventListener("click", function(event)
  {
  if(busyLoading || busyEncoding || busyPreview)
   {
   return;
   }
  if(!wasLoaded)
   {
   fileInfo("No file provided.", 4000, "#fff", "No file loaded...", "#777");
   return;
   }
  realTimePlayback();
  });
 id("downFile").addEventListener("click", function()
  {
  if(wasEncoded)
   {
   id("dacFile").click();
   }
  });
 id("downPrev").addEventListener("click", function()
  {
  if(wasEncoded)
   {
   id("wavFile").click();
   }
  });
 id("advanced").addEventListener("click", checkAdvanced);
 id("monitor").addEventListener("mousewheel", function(event)
  {
  if(!busyPreview)
   {
   return;
   }
  let zoomStep = monitorRefresh < 0.156 ? 0.005 : 0.02;
  if(event.deltaY < 0)
   {
   if(monitorRefresh > 0.041)
    {
    monitorRefresh -= zoomStep;
    }
   return;
   }
  if(monitorRefresh < 0.39)
   {
   monitorRefresh += zoomStep;
   }
  }, {passive: true});
 id("sound").addEventListener("input", function()
  {
  fileLoad(true);
  wasLoaded = false;
  inputFile(false);
  viewInfo(true);
  loader = new FileReader();
  let audio = this.files[0];
  this.value = null;
  if(audio === undefined)
   {
   fileInfo("An unknown error occurred.", 4000, "#ff0000", "No file loaded...", "#777");
   fileLoad(false);
   return;
   }
  fileInfo("Processing...", 0, "#aaa");
  loadedName = audio.name;
  let ext = loadedName.lastIndexOf(".");
  let extension = "";
  if(ext != -1)
   {
   extension = loadedName.substring(ext + 1);
   loadedName = loadedName.substring(0, ext);
   }
  loader.readAsArrayBuffer(audio);
  haltTimeout = setTimeout(function()
   {
   loader.abort();
   viewInfo(false, "Fatal error: loader did not respond", "#ff0000");
   fileInfo("No file loaded...", 0, "#777");
   fileLoad(false);
   }, 30000);
  loader.onload = function()
   {
   let useWorker = (extension == "wav" || extension == "dac");
   clearTimeout(haltTimeout);
   haltTimeout = setTimeout(function()
    {
	if(useWorker){parser.terminate()};
	viewInfo(false, "Fatal error: loader did not respond", "#ff0000");
	fileInfo("No file loaded...", 0, "#777");
	fileLoad(false);
    }, 30000);
   let data = new Uint8Array(loader.result);
   if(useWorker)
    {
    parser = new Worker(waveLoader);
    parser.postMessage({type: extension, raw: data.buffer}, [data.buffer]);
    parser.onmessage = function(event)
     {
	 let feedback = event.data;
	 if(feedback.type == "error")
	  {
	  fileInfo(feedback.desc, 4000, "#ff0000", "No file loaded...", "#777");
	  }
	 else
	  {
	  wasLoaded = true;
	  audioBuffer = new Int32Array(feedback.audio);
	  let parameters = feedback.config;
	  sampleRate = parameters.sRate;
	  audioChannels = parameters.audioCh;
	  dataWidth = parameters.dSize;
	  waveSize = parameters.tSize;
	  audioDuration = parameters.len;
	  channelSamples = parameters.sPerCh;
	  fileInfo(loadedName, 0, "#fff");
	  let channelInfo = "";
	  switch(audioChannels)
	   {
	   case 1:{channelInfo = "mono";}break;
	   case 2:{channelInfo = "stereo";}break;
	   default:{channelInfo = parameters.audioCh;}break;
	   }
	  let basicInfo = "Sampling rate: " + formatSampling(sampleRate) + "; channels: " + channelInfo;
	  viewInfo(false, basicInfo, "#fff");
	  previewInfo(false, 0, audioDuration);
	  cleanBuffers();
	  inputFile(true);
	  if(id("autoLoad").checked)
	   {
	   for(let i=0; i<6; i++)
	    {
	    id("meta" + i).value = feedback.metaData[i].trim();
	    }
	   }
	  }
	 clearTimeout(haltTimeout);
	 parser.terminate();
	 fileLoad(false);
	 }
    parser.onerror = function(event)
     {
     clearTimeout(haltTimeout);
	 parser.terminate();
	 viewInfo(false, event.message, "#ff0000");
     fileInfo("No file loaded...", 0, "#777");
	 fileLoad(false);
	 }
    }
   else
    {
	let decoder;
	try
	 {
	 decoder = new AudioContext();
	 }
	catch
	 {
	 decodingError("Failed to initialize the decoder");
	 clearTimeout(haltTimeout);
	 return;
	 }
    decoder.decodeAudioData(data.buffer,
    function(result)
     {
	 let verifySampling = result.sampleRate;
	 let verifyChannels = result.numberOfChannels;
	 let verifyLength = result.length;
	 if(verifyChannels < 1 || verifyChannels > 256 || verifySampling < 1 || verifySampling > 1000000)
	  {
	  decodingError("Invalid audio parameters");
	  clearTimeout(haltTimeout);
	  return;
	  }
	 if(verifyLength * verifyChannels > 536870912)
      {
      decodingError("Too long audio");
      clearTimeout(haltTimeout);
	  return;
      }
	 wasLoaded = true;
	 sampleRate = verifySampling;
	 audioChannels = verifyChannels;
	 dataWidth = 2;
	 waveSize = verifyLength * verifyChannels * 2 + 44;
	 audioDuration = result.duration;
	 channelSamples = verifyLength;
	 audioBuffer = new Int32Array(verifyLength * audioChannels);
	 for(let i=0; i<audioChannels; i++)
	  {
	  let singleChannel = result.getChannelData(i);
	  let samplePointer = i;
	  for(let j=0; j<verifyLength; j++)
	   {
	   audioBuffer[samplePointer] = singleChannel[j] * 32768;
	   samplePointer += audioChannels;
	   }
	  }
	 fileInfo(loadedName, 0, "#fff");
	 let channelInfo = "";
	 switch(audioChannels)
	  {
	  case 1:{channelInfo = "mono";}break;
	  case 2:{channelInfo = "stereo";}break;
	  default:{channelInfo = parameters.audioCh;}break;
	  }
	 let basicInfo = "Sampling rate: " + formatSampling(sampleRate) + "; channels: " + channelInfo;
	 viewInfo(false, basicInfo, "#fff");
	 previewInfo(false, 0, audioDuration);
	 cleanBuffers();
	 clearTimeout(haltTimeout);
	 inputFile(true);
	 fileLoad(false);
	 },
    function()
	 {
	 decodingError("Unable to decode the file");
	 });
	}
   function decodingError(msg)
    {
	clearTimeout(haltTimeout);
	fileInfo(msg, 4000, "#ff0000", "No file loaded...", "#777");
	fileLoad(false);
	}
   }
  });
 window.addEventListener("keydown", function(event)
  {
  if(event.repeat)
   {
   return;
   }
  let pressed = event.code;
  let isCtrl = event.ctrlKey;
  let isShift = event.shiftKey;
  switch(pressed)
   {
   case "KeyS":
    {
	if(isCtrl)
	 {
	 if(event.cancelable)
	  {
	  event.preventDefault();
	  }
	 if(isShift)
	  {
	  localStorage.removeItem("DAC_settings");
	  console.log("Restored to defaults!");
	  }
	 else
	  {
	  retreiveEncodingParams(true);
	  console.log("Saved!");
	  }
	 }
	}
   break;
   case "Space":
    {
	if(!(/^meta/).test(event.target.id) && event.cancelable)
	 {
	 event.preventDefault();
	 }
	}
   }
  });
 rescale();
 }


function encodeAudio()
 {
 busyEncoding = true;
 retreiveEncodingParams(true);
 cleanBuffers();
 encoder = new Worker(fileEncoder);
 let configData = {
	type: "config",
	values: getEncodingParams()
 };
 let isCursor = false;
 let lastPos = 0;
 let topVal = 1;
 let bottomVal = 0;
 let bitrates = [];
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 id("prBar").value = "0";
 id("monitor").removeEventListener("mousemove", prevListener1);
 id("monitor").removeEventListener("mouseout", prevListener2);
 id("monitor").addEventListener("mousemove", monitorInfo);
 id("monitor").addEventListener("mouseout", cursorLeave);
 prevListener1 = monitorInfo;
 prevListener2 = cursorLeave;
 let audioData = {type: "audio", audio: audioBuffer.buffer, chSamples: channelSamples};
 encoder.postMessage(configData);
 encoder.postMessage(audioData, [audioBuffer.buffer]);
 encoder.postMessage({type: "encode"});
 changeUI(true);
 haltTimeout = setTimeout("responseError()", 60000);
 let start = performance.now();
 let progressNow = 0;
 let dataReceived = 0;
 encoder.onmessage = function(event)
  {
  clearTimeout(haltTimeout);
  haltTimeout = setTimeout("responseError()", 60000);
  let received = event.data;
  if(received.type == "received")
   {
   dataReceived++;
   return;
   }
  if(dataReceived != 2)
   {
   clearTimeout(haltTimeout);
   responseError();
   return;
   }
  switch(received.type)
   {
   case "progress":
    {
	let percent = received.value;
    let runTime = performance.now() - start;
    id("prBar").value = percent;
    if(percent != 0)
     {
     let estimated = Math.round(((100 / percent) - 1) * runTime / 1000);
	 id("progInfo").innerHTML = percent + "% / " + formatTime(estimated) + " left";
     }
	}
   break;
   case "bitrate":
    {
	if(bitrates.length >= 400)
	 {
	 bitrates.shift();
	 }
	bitrates.push(received.value);
	if(bitrates.length > 1)
	 {
	 let graphPoints = scaleGraph(bitrates);
	 topVal = graphPoints.lineMax;
	 bottomVal = graphPoints.lineMin;
	 if(Math.abs(topVal - bottomVal) < 1)
	  {
	  topVal++;
	  }
	 drawGraph(graphPoints.scaled);
	 id("monAverage").innerHTML = "Average: " + graphPoints.average.toFixed(2) + "kbps";
	 if(isCursor)
	  {
	  let b = topVal;
	  let a = (bottomVal - topVal) / 84;
	  let at = a * lastPos + b;
	  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
	  }
	 }
	}
   break;
   case "terminated":
    {
	clearTimeout(haltTimeout);
	audioBuffer = new Int32Array(received.audio);
    encoder.terminate();
    let compressedSize = received.size;
    let avgBitrate = received.bitrate;
	let compRatio = received.ratio;
    let resultString = "Size: " + formatSize(compressedSize) + " (x" + compRatio + ")&nbsp&nbsp&nbspAverage bitrate: " + avgBitrate + "kbps";
    viewInfo(false, resultString, "#fff");
    id("prBar").value = "100";
    id("progInfo").innerHTML = "100% / 0s left";
	const createdFile = new Blob([received.compressed], {type: "application/octet-stream"});
	const previewFile = new Blob([received.wavePreview], {type: "audio/wav"});
    const dacURL = URL.createObjectURL(createdFile);
	const wavURL = URL.createObjectURL(previewFile);
	id("dacFile").setAttribute("download", loadedName.trim() + ".dac");
	id("dacFile").setAttribute("href", dacURL);
	id("wavFile").setAttribute("download", loadedName.trim() + ".wav");
	id("wavFile").setAttribute("href", wavURL);
	wasEncoded = true;
	downloads(true);
	busyEncoding = false;
	setTimeout("changeUI(false)", 1000);
	}
   break;
   case "error":
    {
	clearTimeout(haltTimeout);
	audioBuffer = new Int32Array(received.audio);
	viewInfo(false, received.desc, "#ff0000");
	busyEncoding = false;
	setTimeout("changeUI(false)", 1000);
	}
   break;
   }
  }
 encoder.onerror = function(event)
  {
  clearTimeout(haltTimeout);
  viewInfo(false, event.message, "#ff0000");
  encoder.terminate();
  wasLoaded = false;
  inputFile(false);
  fileInfo("No file loaded...", 0, "#777");
  busyEncoding = false;
  setTimeout("changeUI(false)", 1000);
  }
 function monitorInfo(event)
  {
  isCursor = true;
  let y = event.offsetY - 4;
  if(y < 0){y = 0;}
  else if(y > 84){y = 84;}
  lastPos = y;
  let b = topVal;
  let a = (bottomVal - topVal) / 84;
  let at = a * y + b;
  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
  }
 function cursorLeave()
  {
  isCursor = false;
  id("monCursor").innerHTML = "Cursor: ---";
  }
 }

function scaleGraph(lineData)
 {
 let lineMax = Math.max.apply(Math, lineData);
 let lineMin = Math.min.apply(Math, lineData);
 if(lineMax - lineMin < 1)
  {
  return {scaled: lineData, average: lineData[0] / 1000, lineMax: lineData[0], lineMin: lineData[0]};
  }
 let scaled = [];
 let average = 0;
 let points = lineData.length;
 let a = 249 / (lineMin - lineMax);
 let b = -a * lineMax;
 for(let i=0; i<points; i++)
  {
  average += lineData[i];
  scaled.push(a * lineData[i] + b);
  }
 average /= points * 1000;
 return {scaled, average, lineMax, lineMin};
 }

function drawGraph(lineData)
 {
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 monitor.beginPath();
 monitor.moveTo(0, lineData[0]);
 for(let i=1; i<lineData.length; i++)
  {
  monitor.lineTo(i * 5, lineData[i]);
  }
 monitor.strokeStyle = "white";
 monitor.lineWidth = "4";
 monitor.lineCap = "square";
 monitor.lineJoin = "miter";
 monitor.miterLimit = "1";
 monitor.stroke();
 }

function responseError()
 {
 encoder.terminate();
 wasLoaded = false;
 inputFile(false);
 fileInfo("No file loaded...", 0, "#777");
 viewInfo(false, "Fatal error: encoder stopped responding", "#ff0000");
 previewInfo(true);
 busyEncoding = false;
 setTimeout("changeUI(false)", 1000);
 }

function previewError()
 {
 encoder.terminate();
 wasLoaded = false;
 inputFile(false);
 fileInfo("No file loaded...", 0, "#777");
 previewInfo(true);
 busyPreview = false;
 viewInfo(false, "Fatal error: encoder stopped responding", "#ff0000");
 UIforPreview(false);
 }

function getEncodingParams()
 {
 let sliderPos = [96, 0, 0, 0, 800, getPreset(5, false)];
 let fieldSel = [2, 1, 2, 1];
 if(sliderPos[5] > 100 || sliderPos[5] < 0)
  {
  sliderPos[5] = 15;
  }
 if(id("advanced").checked)
  {
  const upperLimits = [120, 24000, 10000, 10000, 2000];
  const lowerLimits = [48, 3000, 0, 0, 0];
  const fieldLim = [3, 3, 5, 1];
  for(let i=0; i<5; i++)
   {
   if(id("apply" + i).checked)
    {
	let preset = getPreset(i, false);
	if(preset > upperLimits[i] || preset < lowerLimits[i])
	 {
	 continue;
	 }
	sliderPos[i] = preset;
	}
   }
  for(let i=0; i<4; i++)
   {
   let selected = fieldVal(i);
   if(selected <= fieldLim[i] && selected >= 0)
    {
	fieldSel[i] = selected;
	}
   }
  }
 const correspond = [[15, 8, 2.5, 1.25], [4, 8, 16, 32], [0.5, 1, 2, 5, 10, 30]];
 for(let i=0; i<3; i++)
  {
  fieldSel[i] = correspond[i][fieldSel[i]];
  }
 let applyMeta = id("inclMeta").checked;
 let addMeta = [];
 if(applyMeta && !busyPreview)
  {
  for(let i=0; i<6; i++)
   {
   addMeta.push(id("meta" + i).value.trim());
   }
  }
 return {
	quality: sliderPos[5],
	rate: sampleRate,
	bitDepth: dataWidth,
	channels: audioChannels,
	dynaRange: sliderPos[0],
	freqRange: sliderPos[1],
	upBitLim: sliderPos[2],
	loBitLim: sliderPos[3],
	lowFreqRange: sliderPos[4],
	transientSens: fieldSel[0],
	subbandSize: fieldSel[1],
	keyframeInt: fieldSel[2],
	adaptAlloc: fieldSel[3],
	origSize: waveSize,
	includeMeta: applyMeta,
	fileMetaData: addMeta
  };
 }
 
function retreiveEncodingParams(store)
 {
 const topLimits = [100, 1, 1, 1, 120, 210, 200, 200, 200, 3, 3, 5, 1, 1, 1, 1, 1, 1];
 const bottomLimits = [0, 0, 0, 0, 48, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
 const defaults = [15, 1, 1, 0, 96, 146, 54, 10, 80, 2, 1, 2, 1, 0, 0, 0, 0, 0];
 const fieldIDs = ["qual", "autoLoad", "inclMeta", "advanced", "dnRange", "ctFreq", "upLim", "loLim", "impFreq", "transientField", "subbandField", "keyframeField", "adaptAllocApply", "apply0", "apply1", "apply2", "apply3", "apply4"];
 const fieldTypes = [false, true, true, true, false, false, false, false, false, false, false, false, true, true, true, true, true, true];
 const storedNames = ["quality", "loadMetaFromFile", "includeMetaInFile", "advancedPanel", "dynamicRange", "cutoffFrequency", "upperBitLimit", "lowerBitLimit", "lowerFrequencies", "transientSensitivity", "subbandSize", "keyframeInterval", "adaptiveAllocation", "customDynamicRange", "customCutoff", "customUpperLim", "customLowerLim", "customLowerFreq"];
 let allPresets = {};
 if(store)
  {
  for(let i=0; i<storedNames.length; i++)
   {
   let setNow = fieldTypes[i] ? id(fieldIDs[i]).checked + 0 : id(fieldIDs[i]).value;
   let parsed = parseFloat(setNow);
   if(isNaN(setNow))
    {
    allPresets[storedNames[i]] = defaults[i];
    continue;
    }
   if(setNow < bottomLimits[i] || setNow > topLimits[i])
    {
    allPresets[storedNames[i]] = defaults[i];
    continue;
    }
   allPresets[storedNames[i]] = setNow;
   }
  if(monitorRefresh < 0.039 || monitorRefresh > 0.41)
   {
   monitorRefresh = 0.15;
   }
  allPresets.monitorRefreshRate = monitorRefresh;
  localStorage.setItem("DAC_settings", JSON.stringify(allPresets));
  return;
  }
 const pattern = /^^{("[a-zA-Z0-9]+":"?[0-9\.]+"?\,?)*}$/g;
 let settingString = localStorage.getItem("DAC_settings");
 if(!pattern.test(settingString))
  {
  retreiveEncodingParams(true);
  return;
  }
 allPresets = JSON.parse(settingString);
 for(let i=0; i<storedNames.length; i++)
  {
  let stored = parseFloat(allPresets[storedNames[i]]);
  let newVal = 0;
  if(isNaN(stored))
   {
   newVal = defaults[i];
   }
  else if(stored < bottomLimits[i] || stored > topLimits[i])
   {
   newVal = defaults[i];
   }
  else
   {
   newVal = stored;
   }
  fieldTypes[i] ? id(fieldIDs[i]).checked = newVal : id(fieldIDs[i]).value = newVal;
  }
 for(let i=0; i<6; i++)
  {
  getPreset(i, true);
  }
 checkAdvanced();
 let storedRefresh = parseFloat(allPresets.monitorRefreshRate);
 if(isNaN(storedRefresh))
  {
  monitorRefresh = 0.15;
  return;
  }
 if(storedRefresh < 0.039 || storedRefresh > 0.41)
  {
  monitorRefresh = 0.15;
  return;
  }
 monitorRefresh = storedRefresh;
 }


function realTimePlayback()
 {
 let fragLen = 0.05;
 let realTimePlayer;
 let playBuffer;
 let currentBuffer;
 let audioTime = 0;
 let playerTime = 0;
 let prevTime = 1;
 let firstFrame = true;
 let seek = false;
 let wasStopped = false;
 let nextReady = true;
 let usedChannels = audioChannels > 1 ? 2 : 1;
 if(audioDuration < fragLen)
  {
  viewInfo(false, "Error: too short audio", "#ff0000");
  return;
  }
 if(id("resInfo").style.color = "#ff0000")
  {
  id("resInfo").innerHTML = "";
  }
 try
  {
  realTimePlayer = new AudioContext({sampleRate});
  }
 catch(error)
  {
  let shorten = error.toString();
  if(shorten.length > 100)
   {
   shorten = shorten.slice(0, 97) + "...";
   }
  viewInfo(false, 'Error while setting up playback.<br><span style="font-size:10px; display:block">' + shorten + '</span>', "#ff0000");
  return;
  }
 busyPreview = true;
 UIforPreview(true);
 let bitrates = [];
 let sumTime = 0;
 let sumVal = 0;
 let sumFrames = 0;
 let topVal = 1;
 let bottomVal = 0;
 let isCursor = false;
 let lastPos = 0;
 let monitor = id("monitor").getContext("2d");
 monitor.clearRect(0, 0, 2000, 250);
 encoder = new Worker(fileEncoder);
 let configData = {type: "config", values: getEncodingParams()};
 let audioData = {type: "audio", audio: audioBuffer.buffer, chSamples: channelSamples};
 encoder.postMessage(configData);
 encoder.postMessage(audioData, [audioBuffer.buffer]);
 encoder.postMessage({type: "slice", startFrom: 0, fragment: fragLen});
 haltTimeout = setTimeout("previewError()", 5000);
 id("forw").addEventListener("mousedown", seekForw);
 id("rev").addEventListener("mousedown", seekRev);
 id("play").addEventListener("mouseup", stopRequest);
 id("monitor").addEventListener("contextmenu", clearMonitor);
 id("monitor").removeEventListener("mousemove", prevListener1);
 id("monitor").removeEventListener("mouseout", prevListener2);
 id("monitor").addEventListener("mousemove", monitorInfo);
 id("monitor").addEventListener("mouseout", cursorLeave);
 prevListener1 = monitorInfo;
 prevListener2 = cursorLeave;
 window.addEventListener("keydown", keySeek);
 encoder.onmessage = function(event)
  {
  clearTimeout(haltTimeout);
  haltTimeout = setTimeout("previewError()", 2000);
  let received = event.data;
  switch(received.type)
   {
   case "success":
    {
	if(!seek){audioTime = received.endStamp;}
	let roundStamp = Math.round(audioTime);
	if(prevTime != roundStamp)
	 {
	 previewInfo(false, audioTime, audioDuration);
     }
	prevTime = roundStamp;
	let audioBuffer = realTimePlayer.createBuffer(usedChannels, received.sampleLen, sampleRate);
    audioBuffer.copyToChannel(received.audioL, 0);
    if(usedChannels == 2)
     {
	 audioBuffer.copyToChannel(received.audioR, 1);
	 }
    currentBuffer = playBuffer;
	playBuffer = realTimePlayer.createBufferSource();
    playBuffer.buffer = audioBuffer;
    playBuffer.connect(realTimePlayer.destination);
    playBuffer.onended = requestNext;
    if(firstFrame)
     {
	 firstFrame = false;
	 requestNext();
	 playerTime = realTimePlayer.currentTime;
	 }
	playBuffer.start(playerTime);
	playerTime += received.duration;
	sumTime += received.duration;
	sumFrames++;
	sumVal += received.avgBitrate;
	nextReady = true;
	if(sumTime >= monitorRefresh)
	 {
	 sumTime = 0;
	 if(bitrates.length >= 400)
	  {
	  bitrates.shift();
	  }
	 let chunkRate = sumVal / sumFrames;
	 bitrates.push(chunkRate);
	 if(bitrates.length > 1)
	  {
	  let graphPoints = scaleGraph(bitrates);
	  drawGraph(graphPoints.scaled);
	  topVal = graphPoints.lineMax;
	  bottomVal = graphPoints.lineMin;
	  if(Math.abs(topVal - bottomVal) < 1)
	   {
	   topVal++;
	   }
	  id("monCurrent").innerHTML = "Current: " + (chunkRate / 1000).toFixed(2) + "kbps";
	  id("monAverage").innerHTML = "Average: " + graphPoints.average.toFixed(2) + "kbps";
	  if(isCursor)
	   {
	   let b = topVal;
	   let a = (bottomVal - topVal) / 84;
	   let at = a * lastPos + b;
	   id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
	   }
	  }
	 sumVal = 0;
	 sumFrames = 0;
	 }
	}
   break;
   case "stopped":
    {
	endPreview();
	audioBuffer = new Int32Array(received.audio);
	}
   break;
   case "error":
    {
	endPreview();
	audioBuffer = new Int32Array(received.audio);
	viewInfo(false, received.desc, "#ff0000");
	}
   break;
   }
  }
 encoder.onerror = function(event)
  {
  encoder.terminate();
  viewInfo(false, event.message, "#ff0000");
  wasLoaded = false;
  inputFile(false);
  endPreview();
  previewInfo(true);
  fileInfo("No file loaded...", 0, "#777");
  }
 function requestNext()
  {
  if(wasStopped)
   {
   return;
   }
  if(!nextReady)
   {
   if(fragLen < 1)
    {
	fragLen += 0.01 + Math.round(fragLen * 20) / 100;
	}
   console.log("Adjusted to " + fragLen + "s chunk length");
   }
  if(audioTime + fragLen >= audioDuration)
   {
   audioTime = 0;
   }
  configData.values = getEncodingParams();
  encoder.postMessage(configData);
  encoder.postMessage({type: "slice", startFrom: audioTime, fragment: fragLen});
  nextReady = false;
  seek = false;
  }
 function seekForw(event)
  {
  let seekTime = 5;
  if(event.ctrlKey)
   {
   seekTime = 1;
   }
  else if(event.shiftKey)
   {
   seekTime = 30;
   }
  seekBy(seekTime, false);
  }
 function seekRev(event)
  {
  if(event.ctrlKey && event.shiftKey)
   {
   audioTime = 0;
   seek = true;
   return;
   }
  let seekTime = 5;
  if(event.ctrlKey)
   {
   seekTime = 1;
   }
  else if(event.shiftKey)
   {
   seekTime = 30;
   }
  seekBy(seekTime, true);
  }
 function keySeek(event)
  {
  let pressed = event.code;
  let isShift = event.shiftKey;
  if(pressed.startsWith("Arrow") && event.cancelable)
   {
   event.preventDefault();
   }
  switch(pressed)
   {
   case "Space":
    {
	stopRequest();
	}
   break;
   case "ArrowRight":
    {
	seekBy(5, false);
	}
   break;
   case "ArrowLeft":
    {
	if(isShift)
	 {
	 audioTime = 0;
	 seek = true;
	 return;
	 }
	seekBy(5, true);
	}
   break;
   case "ArrowUp":
    {
	isShift ? seekBy(30, false) : seekBy(1, false);
	}
   break;
   case "ArrowDown":
    {
	isShift ? seekBy(30, true) : seekBy(1, true);
	}
   break;
   }
  }
 function seekBy(jump, dir)
  {
  if(dir)
   {
   let newTime = audioTime - jump;
   if(newTime < 0)
    {
    newTime = audioDuration - jump;
    if(newTime < 0)
     {
	 newTime = 0;
	 }
    }
   audioTime = newTime;
   seek = true;
   return;
   }
  let newTime = audioTime + jump;
  if(newTime >= audioDuration)
   {
   newTime = 0;
   }
  audioTime = newTime;
  seek = true;
  }
 function clearMonitor(event)
  {
  if(event.cancelable)
   {
   event.preventDefault();
   }
  let elems = bitrates.length;
  if(elems >= 20)
   {
   bitrates = bitrates.slice(elems - 20, elems);
   }
  }
 function monitorInfo(event)
  {
  isCursor = true;
  let y = event.offsetY - 4;
  if(y < 0){y = 0;}
  else if(y > 84){y = 84;}
  lastPos = y;
  let b = topVal;
  let a = (bottomVal - topVal) / 84;
  let at = a * y + b;
  id("monCursor").innerHTML = "Cursor: " + (at / 1000).toFixed(2) + "kbps";
  }
 function cursorLeave()
  {
  isCursor = false;
  id("monCursor").innerHTML = "Cursor: ---";
  }
 function stopRequest()
  {
  encoder.postMessage({type: "stop"});
  wasStopped = true;
  try{playBuffer.stop(); currentBuffer.stop();}catch{}
  }
 function endPreview()
  {
  clearTimeout(haltTimeout);
  try{playBuffer.stop()}catch{}
  id("forw").removeEventListener("mousedown", seekForw);
  id("rev").removeEventListener("mousedown", seekRev);
  id("play").removeEventListener("click", stopRequest);
  id("monitor").removeEventListener("contextmenu", clearMonitor);
  window.removeEventListener("keydown", keySeek);
  busyPreview = false;
  UIforPreview(false);
  }
 }

let timeoutExecuted;

function fileInfo(text, dur, clr, textAft, clrAft)
 {
 clearTimeout(timeoutExecuted);
 id("fileName").style.color = clr;
 id("fileName").innerHTML = text;
 if(id("fileName").clientWidth < id("fileName").scrollWidth)
  {
  for(let i=12; i<text.length; i++)
   {
   id("fileName").innerHTML = text.substr(0, i).trim() + "...";
   if(id("fileName").clientWidth < id("fileName").scrollWidth)
    {
	id("fileName").innerHTML = text.substr(0, i - 1).trim() + "...";
	break;
	}
   }
  }
 if(dur == 0)
  {
  return;
  }
 timeoutExecuted = setTimeout(function()
  {
  id("fileName").style.color = clrAft;
  id("fileName").innerHTML = textAft;
  if(id("fileName").clientWidth < id("fileName").scrollWidth)
   {
   for(let i=12; i<textAft.length; i++)
    {
    id("fileName").innerHTML = textAft.substr(0, i).trim() + "...";
    if(id("fileName").clientWidth < id("fileName").scrollWidth)
     {
	 id("fileName").innerHTML = textAft.substr(0, i - 1).trim() + "...";
	 break;
	 }
    }
   }
  }, dur);
 }

function viewInfo(hide, text, clr)
 {
 if(hide)
  {
  id("resInfo").style.opacity = "0";
  return;
  }
 id("resInfo").style.color = clr;
 id("resInfo").innerHTML = text;
 id("resInfo").style.opacity = "1";
 }
 
function previewInfo(unknown, timeStamp, totalTime)
 {
 if(unknown)
  {
  id("prevInfo").innerHTML = "-:-- / -:--";
  return;
  }
 let time1 = formatTimeSimple(Math.round(timeStamp));
 let time2 = formatTimeSimple(Math.round(totalTime));
 id("prevInfo").innerHTML = time1 + "/" + time2;
 }

function changeUI(busy)
 {
 const buttonIDs = ["loadNew", "downFile", "downPrev", "rev", "play", "forw"];
 clearMonitor();
 if(busy)
  {
  for(let buttID of buttonIDs)
   {
   id(buttID).style.pointerEvents = "none";
   }
  id("enc").style.pointerEvents = "none";
  id("resInfo").style.opacity = "0";
  id("progInfo").style.color = "#fff";
  id("progInfo").innerHTML = "Initializing...";
  return;
  }
 id("progInfo").style.color = "#818181";
 id("progInfo").innerHTML = "Currently idle...";
 for(let buttID of buttonIDs)
  {
  id(buttID).style.pointerEvents = "all";
  }
 if(wasLoaded)
  {
  id("enc").style.pointerEvents = "all";
  }
 id("prBar").value = "0";
 }

function UIforPreview(start)
 {
 const buttonIDs = ["loadNew", "downFile", "downPrev"];
 clearMonitor();
 if(start)
  {
  for(let buttID of buttonIDs)
   {
   id(buttID).style.pointerEvents = "none";
   }
  id("play").setAttribute("class", "prevBtn pauseBtn");
  id("enc").style.pointerEvents = "none";
  id("forw").style.pointerEvents = "all";
  id("rev").style.pointerEvents = "all";
  id("progInfo").style.color = "#fff";
  id("progInfo").innerHTML = "Preview in progress...";
  previewInfo(false, 0, audioDuration);
  return;
  }
 id("progInfo").style.color = "#818181";
 id("progInfo").innerHTML = "Currently idle...";
 id("play").setAttribute("class", "prevBtn playBtn");
 id("loadNew").style.pointerEvents = "all";
 id("forw").style.pointerEvents = "none";
 id("rev").style.pointerEvents = "none";
 if(wasEncoded)
  {
  id("downFile").style.pointerEvents = "all";
  id("downPrev").style.pointerEvents = "all";
  }
 if(wasLoaded)
  {
  id("enc").style.pointerEvents = "all";
  previewInfo(false, 0, audioDuration);
  }
 }

function clearMonitor()
 {
 id("monCurrent").innerHTML = "Current: ---";
 id("monAverage").innerHTML = "Average: ---";
 id("monCursor").innerHTML = "Cursor: ---";
 }

function formatSize(size)
 {
 let suffixes = ["B", "KB", "MB", "GB"];
 let bases = [1, 1024, 1048576, 1073741824];
 let precisions = [0, 2, 3, 4];
 let chosen = 0;
 for(let i=1; i<4; i++)
  {
  if(size >= bases[i])
   {
   chosen++;
   continue;
   }
  break;
  }
 let formatted = (size / bases[chosen]).toFixed(precisions[chosen]) + suffixes[chosen];
 return formatted;
 }

function formatSampling(rate)
 {
 let suffixes = ["Hz", "kHz", "kHz", "kHz"];
 let bases = [1, 1000, 10000, 100000];
 let precisions = [0, 2, 1, 0];
 let chosen = 0;
 for(let i=1; i<4; i++)
  {
  if(rate >= bases[i])
   {
   chosen++;
   continue;
   }
  break;
  }
 if(chosen > 0)
  {
  rate /= 1000;
  }
 let formatted = rate.toFixed(precisions[chosen]) + suffixes[chosen];
 return formatted;
 }

function formatTime(seconds)
 {
 let divide = 3600;
 let suffixes = ["h", "min"];
 let timeString = "";
 let added = false;
 for(let i=0; i<3; i++)
  {
  let single = parseInt(seconds / divide);
  if(single || added || i == 2)
   {
   if(added)
    {
	timeString += single.toString().padStart(2, "0");
	}
   else
    {
	timeString += single;
	}
   i < 2 ? timeString += suffixes[i] + " " : timeString += "s";
   added = true;
   }
  seconds %= divide;
  divide /= 60;
  }
 return timeString;
 }

function formatTimeSimple(seconds)
 {
 let divide = 3600;
 let timeString = "";
 let added = false;
 for(let i=0; i<3; i++)
  {
  let single = parseInt(seconds / divide);
  if(single || added || i == 1)
   {
   if(added)
    {
	timeString += single.toString().padStart(2, "0");
	}
   else
    {
	timeString += single;
	}
   if(i < 2)
    {
	timeString += ":";
	}
   added = true;
   }
  seconds %= divide;
  divide /= 60;
  }
 return timeString;
 }

function cleanBuffers()
 {
 downloads(false);
 encodedBuffer = new Uint8Array(0);
 decodedBuffer = new Uint8Array(0);
 wasEncoded = false;
 }
 
function downloads(present)
 {
 if(present)
  {
  id("downFile").style.opacity = "1";
  id("downPrev").style.opacity = "1";
  id("downFile").style.pointerEvents = "all";
  id("downPrev").style.pointerEvents = "all";
  return;
  }
 id("downFile").style.pointerEvents = "none";
 id("downPrev").style.pointerEvents = "none";
 id("downFile").style.opacity = "0.7";
 id("downPrev").style.opacity = "0.7";
 }
 
function inputFile(present)
 {
 if(present)
  {
  id("play").style.pointerEvents = "all";
  id("enc").style.pointerEvents = "all";
  id("enc").style.opacity = "1";
  return;
  }
 id("play").style.pointerEvents = "none";
 id("enc").style.pointerEvents = "none";
 id("enc").style.opacity = "0.7";
 }
 
function fileLoad(start)
 {
 busyLoading = start;
 if(start)
  {
  id("loadNew").style.pointerEvents = "none";
  return;
  }
 id("loadNew").style.pointerEvents = "all";
 }

function getPreset(which, update)
 {
 switch(which)
  {
  case 0:
   {
   let set = parseInt(id("dnRange").value || 96);
   if(update){id("dnRangeVal").innerHTML = set + "dB";}
   return set;
   }
  case 1:
   {
   let set = parseInt(id("ctFreq").value || 146);
   set = (set + 30) * 100;
   if(update){id("ctFreqVal").innerHTML = (set / 1000).toFixed(1) + "kHz";}
   return set;
   }
  case 2:
   {
   let set = parseInt(id("upLim").value || 54);
   set *= set * 0.2474747 + 0.50505;
   set = Math.round(set);
   if(update){id("upLimVal").innerHTML = set;}
   return set;
   }
  case 3:
   {
   let set = parseInt(id("loLim").value || 54);
   set *= set * 0.2474747 + 0.50505;
   set = Math.round(set);
   if(update){id("loLimVal").innerHTML = set;}
   return set;
   }
  case 4:
   {
   let set = parseInt(id("impFreq").value || 80) * 10;
   if(update)
    {
	if(set >= 1000)
	 {
	 id("impFreqVal").innerHTML = (set / 1000).toFixed(2) + "kHz";
	 }
	else
	 {
	 id("impFreqVal").innerHTML = set + "Hz"
	 }
	}
   return set;
   }
  case 5:
   {
   let set = parseFloat(id("qual").value || 15);
   if(update){id("qualInfo").innerHTML = "Quality: " + set.toFixed(2);}
   return set;
   }
  }
 return 0;
 }

function rawVal(which)
 {
 const sliders = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 return parseFloat(id(sliders[which]).value || 0);
 }

function fieldVal(which)
 {
 if(which == 3)
  {
  return id("adaptAllocApply").checked + 0;
  }
 const fields = ["transientField", "subbandField", "keyframeField"];
 return parseInt(id(fields[which]).value || 0);
 }

function isBorder(which, dir)
 {
 const sliders = ["dnRange", "ctFreq", "upLim", "loLim", "impFreq", "qual"];
 const upper = parseInt(id(sliders[which]).max);
 const lower = parseInt(id(sliders[which]).min);
 const set = parseFloat(id(sliders[which]).value);
 return (!dir && set >= upper) || (dir && set <= lower);
 }
 
function checkAdvanced()
 {
 id("advanced").checked ? id("advBox").style.height = "400px" : id("advBox").style.height = "36px";
 }

function rescale()
 {
 let UIscale = 1;
 window.addEventListener("resize", adjustSize);
 function adjustSize()
  {
  let w = window.innerWidth;
  let h = window.innerHeight;
  let x_ovf = w / 1200;
  let y_ovf = h / 880;
  let scaleBy = Math.min(x_ovf, y_ovf);
  if(scaleBy > 1)
   {
   scaleBy = 1;
   }
  let topMarg = 355 * scaleBy - 355;
  if(topMarg < -100)
   {
   topMarg = -100;
   }
  document.body.style.transform = "scale(" + scaleBy + ")";
  document.body.style.marginTop = topMarg + "px";
  }
 adjustSize();
 }

function normalArray(from)
 {
 let sliced = [];
 for(let i=0; i<from.length; i++)
  {
  sliced.push(from[i]);
  }
 return sliced;
 }
 
function getFrDbg(which, channel)
 {
 let offset = which * 512 * audioChannels + channel;
 let sliced = new Array(1024);
 let at = offset;
 for(let i=0; i<1024; i++)
  {
  sliced[i] = audioBuffer[at];
  at += audioChannels;
  }
 return sliced;
 }


</script>

<style>

h1 {
	margin-top: 3%;
	display: block;
	font-family: Verdana;
	color: white;
	padding-left: 50px;
	padding-right: 50px;
	font-size: calc(1.4vw + 21px);
	cursor: default;
}

.metaData {
	width: 250px;
	height: 33px;
	margin-top: 13px;
	border: 1px solid white;
	color: white;
	font-size: 20px;
	font-family: Verdana;
	background-color: #1c1c1c;
	padding-left: 7px;
	padding-right: 7px;
	display: inline-block;
	outline: none;
}

.btn {
	height: 30px;
	border: 1px solid white;
	color: white;
	font-size: 18px;
	font-family: Verdana;
	background-color: #1c1c1c;
	cursor: pointer;
	opacity: 1;
	transition: 0.3s opacity;
	display: inline-block;
	outline: none;
}

.btn:hover {
	box-shadow: 0px 0px 3px 0.7px #b2b2b2;
}

.contentBox {
	display: inline-block;
	position: relative;
	background-color: #1e1e1e;
	border: 3px solid white;
	border-radius: 4px;
	color: white;
	text-align: center;
	font-family: Verdana;
	font-size: 23px;
	vertical-align: top;
	pointer-events: all;
	box-shadow: 2px 2px 6px 0px #a7a7a7;
	overflow: hidden;
	white-space: normal;
	cursor: default;
}

.slider {
	position: relative;
	display: inline-block;
	vertical-align: top;
	cursor: pointer;
	width: 46px;
	height: 24px;
}

.slider input {
	display: none;
}

.switch:before {
	position: absolute;
	content: "";
	height: 18px;
	width: 18px;
	left: 4px;
	bottom: 3px;
	background-color: #fff;
	transition: 0.2s;
	border-radius: 50%;
}

.switch {
	position: absolute;
	background-color: #ccc;
	transition: 0.2s;
	border-radius: 20px;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}

input:checked + .switch:before {
	transform: translateX(20px);
}

input:checked + .switch {
	background-color: #18e518;
}

.horSlider {
	-webkit-appearance: none;
	appearance: none;
	background: transparent;
	outline: none;
}

.horSlider::-webkit-slider-runnable-track {
  height: 6px;
  cursor: pointer;
  border-radius: 2px;
  background: #eee;
}

.horSlider::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	height: 20px;
	width: 8px;
	border-radius: 2px;
	background: #18e518;
	cursor: pointer;
	margin-top: -7px;
	border: none;
}

progress {
	-webkit-appearance: none;
	appearance: none;
	width: 400px;
	height: 13px;
}

progress::-webkit-progress-bar {
	background: #eee;
	border-radius: 2px;
}

progress:not([value="0"])::-webkit-progress-value {
	background: #18e518;
    border-radius: 2px;
	box-shadow: 0px 0px 5px 1px #18e518;
}

.sliderBox {
	position: relative;
	display: inline-block;
	text-align: center;
	margin-top: 150px;
	vertical-align: top;
	float: left;
}

.sliderBg {
	background-color: #3a3a3a;
	border-radius: 3px;
	display: inline-block;
	position: absolute;
	margin-left: 55px;
	margin-top: -129px;
	z-index: 0;
	width: 105px;
	height: 202px;
	top: -2px;
	left: -4px;
}

.sliderDesc {
	font-size: 11px;
	font-family: Verdana;
	color: #fff;
	display: inline-block;
	position: absolute;
	margin-left: 61px;
	margin-top: -128px;
	white-space: nowrap;
	z-index: 1;
	cursor: default;
}

.minVal {
	font-size: 9px;
	font-family: Verdana;
	color: #fff;
	display: inline-block;
	position: absolute;
	margin-top: 41px;
	margin-left: 62px;
	white-space: nowrap;
	z-index: 1;
	cursor: default;
}

.topVal {
	font-size: 9px;
	font-family: Verdana;
	color: #fff;
	display: inline-block;
	position: absolute;
	margin-left: 57px;
	margin-top: -78px;
	white-space: nowrap;
	z-index: 1;
	cursor: default;
}

.currVal {
	font-size: 13px;
	font-family: Verdana;
	color: #fff;
	display: inline-block;
	position: absolute;
	margin-left: 93px;
	margin-top: -110px;
	white-space: nowrap;
	z-index: 1;
	cursor: default;
}

.applyBox {
	-webkit-appearance: none;
	appearance: none;
	border: 1px solid #fff;
	border-radius: 50%;
	outline: none;
	cursor: pointer;
	width: 10px;
	height: 10px;
	display: block;
	background-color: #505050;
	position: absolute;
	margin-left: 74px;
	margin-top: -106px;
	z-index: 1;
	vertical-align: top;
}

.applyBox:checked {
	background-color: #18f518;
	box-shadow: 0px 0px 4px 1px #18e518;
	border: none;
}

.vertSlider {
	-webkit-appearance: none;
	appearance: none;
	background: transparent;
	outline: none;
	transform: rotate(270deg);
	transform-origin: center;
	width:150px;
	height:20px;
	margin-left: 29px;
	margin-top: -22px;
	cursor:pointer;
	display:inline-block;
	position: absolute;
	z-index: 1;
}

.vertSlider::-webkit-slider-runnable-track {
  height: 6px;
  cursor: pointer;
  border-radius: 2px;
  background: #eee;
}

.vertSlider::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	height: 20px;
	width: 30px;
	border-radius: 2px;
	cursor: pointer;
	margin-top: -7px;
	background: linear-gradient(to right, #16b516 0%, #18f518 30%, #18f518 47%, #222 47%, #222 53%, #18f518 53%, #18f518 70%, #16b516 100%);
	border: none;
}

.prevBtn {
	width: 20px;
	height: 12px;
	margin-top: 12px;
	border: none;
	background-color: transparent;
	position: relative;
	display: inline-block;
	float: left;
	cursor: pointer;
	outline: none;
}

.revBtn::before,
.revBtn::after {
	content: "";
	display: block;
	position: absolute;
	top: -5%;
	left: 0%;
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 7px 12px 7px 0;
	border-color: transparent #fff transparent transparent;
}

.revBtn::after {
	left: 50%;
}

.playBtn::before {
	content: "";
	display: block;
	position: absolute;
	top: -35%;
	left: 5%;
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 12px 0 12px 18px;
	border-color: transparent transparent transparent #fff;
}

.pauseBtn::before {
	content: "";
	display: block;
	position: absolute;
	top: -20%;
	left: -5%;
	width: 0;
	height: 0;
	border: 10px solid #fff;
}

.ffBtn::before,
.ffBtn::after {
	content: "";
	display: block;
	position: absolute;
	top: -5%;
	left: 0%;
	width: 0;
	height: 0;
	border-style: solid;
	border-width: 7px 0 7px 12px;
	border-color: transparent transparent transparent #fff;
}

.ffBtn::after {
	left: 50%;
}

select {
	height: 23px;
	font-size: 12px;
	font-family: Verdana;
	color: #fff;
	background-color: #1c1c1c;
	border: 1px solid #fff;
	display: inline-block;
	outline: none;
	cursor: pointer;
	padding-left: 3px;
	vertical-align: top;
}

select:hover {
	box-shadow: 0px 0px 3px 0.7px #b2b2b2;
}

.selectDesc {
	font-size: 12px;
	display: inline-block;
	vertical-align: top;
	cursor: default;
}

</style>

</head>
<body onload="run()" style="text-align:center; background:radial-gradient(circle at 50% 0%, #363636, #050505); background-color:#141414; background-image:url(graphics/speakers.png); background-repeat:no-repeat; background-size:cover; margin:0; height:100vh; overflow:hidden; transform:scale(1); white-space:nowrap">
<div style="text-align:center; margin:0; position:relative; width:100vw">
<h1>DAC - Dynamic Audio Codec</h1>
<div style="text-align:center; position:relative; display:inline-block; margin-top:1%">
<div class="contentBox" id="loaderBox" style="width:700px; height:40px; margin-top:0px; padding-top:9px; padding-left:7px; padding-right:10px">
<span style="float:left; cursor:default">INPUT FILE:</span>
<span id="fileName" style="color:#777; margin-left:7px; float:left; cursor:default; max-width:410px; white-space:nowrap">No file loaded...</span>
<input type="button" id="loadNew" class="btn" value="Load audio" style="width:130px; float:right"/>
<input type="file" accept=".wav,.dac,.mp3,.aac,.ogg,.flac" id="sound" style="display:none"/>
<a href="" download="" id="dacFile" style="display:none"></a>
<a href="" download="" id="wavFile" style="display:none"></a>
</div>
<div class="contentBox" id="qualityBox" style="width:700px; height:55px; display:block; margin-top:3%; padding-top:9px; padding-left:7px; padding-right:10px">
<div style="text-align:center; position:relative; display:inline-block">
<span id="qualInfo" style="font-size:19px; display:block; cursor:default; margin-bottom:3px">Quality: 15.00</span>
<input type="range" class="horSlider" id="qual" min="0" max="100" step="0.05" value="15" style="width:420px; height:20px; outline:none; cursor:pointer; display:inline-block"/>
</div>
<input type="button" id="enc" class="btn" value="Compress" style="width:130px; float:right; margin-top:7px; pointer-events:none; opacity:0.7"/>
</div>
<div class="contentBox" id="infoBox" style="width:707px; height:90px; display:block; margin-top:3%; padding-right:10px">
<div style="text-align:center; position:relative; display:inline-block; vertical-align:top; margin-top:10px">
<span id="progInfo" style="font-size:14px; display:block; cursor:default; color:#818181">Currently idle...</span>
<progress id="prBar" max="100" value="0" style="outline:none; display:block; margin-top:10px; margin-bottom:8px; cursor:default"></progress>
<span id="resInfo" style="font-size:14px; display:block; cursor:default; opacity:0; transition:0.3s; max-width:400px; white-space:nowrap">Encoding results...</span>
</div>
<div style="text-align:center; position:relative; display:inline-block; vertical-align:top; float:right; margin-right:15px">
<span style="font-size:17px; display:block; cursor:default; margin-top:8px">Downloads:</span>
<input type="button" id="downFile" class="btn" value="DAC file" style="width:95px; margin-top:8px; display:inline-block; vertical-align:top; pointer-events:none; opacity:0.7"/>
<input type="button" id="downPrev" class="btn" value="Wave file" style="width:95px; margin-top:8px; display:inline-block; vertical-align:top; pointer-events:none; opacity:0.7"/>
</div>
</div>
<div class="contentBox" id="advBox" style="width:700px; height:36px; display:block; margin-top:3%; padding-left:7px; padding-right:10px; transition:0.4s ease-in-out height">
<span style="font-size:15px; display:inline-block; cursor:default; margin-top:8px; margin-left:10px; float:left">Real-time preview:</span>
<button id="rev" class="prevBtn revBtn" style="margin-left:10px; pointer-events:none"></button>
<button id="play" class="prevBtn playBtn" style="margin-left:30px; margin-top:10px; pointer-events:none"></button>
<button id="forw" class="prevBtn ffBtn" style="margin-left:25px; pointer-events:none"></button>
<span id="prevInfo" style="font-size:15px; margin-top:9px; margin-left:20px; width:0px; white-space:nowrap; display:inline-block; float:left; cursor:default; color:#fff">-:-- / -:--</span>
<span style="font-size:18px; margin-top:7px; margin-left:185px; display:inline-block; vertical-align:top; cursor:default">Advanced panel</span>
<label class="slider" style="margin-top:6px; margin-left:4px">
<input type="checkbox" id="advanced" class="hide"/>
<span class="switch"></span>
</label>
<div style="position:relative; display:block; float:left; vertical-align:top; margin-left:275px; white-space:nowrap">
<div class="sliderBox" style="margin-left:-322px">
<span class="sliderDesc">Dynamic Range</span>
<input type="checkbox" id="apply0" class="applyBox"/>
<span id="dnRangeVal" class="currVal">96dB</span>
<input type="range" class="vertSlider" id="dnRange" min="48" max="120" step="1" value="96"/>
<span class="topVal">120dB</span>
<span class="minVal">48dB</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:-205px">
<span class="sliderDesc" style="margin-left:57px">Cutoff Frequency</span>
<input type="checkbox" id="apply1" class="applyBox" style="margin-left:68px"/>
<span id="ctFreqVal" class="currVal" style="margin-left:86px">17.6kHz</span>
<input type="range" class="vertSlider" id="ctFreq" min="0" max="210" step="1" value="146"/>
<span class="topVal" style="margin-left:60px">24kHz</span>
<span class="minVal" style="margin-left:65px">3kHz</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:-88px">
<span class="sliderDesc" style="margin-left:62px">Upper Bit Limit</span>
<input type="checkbox" id="apply2" class="applyBox"/>
<span id="upLimVal" class="currVal">749</span>
<input type="range" class="vertSlider" id="upLim" min="2" max="200" step="1" value="54"/>
<span class="topVal" style="margin-left:60px">10000</span>
<span class="minVal" style="margin-left:82px">2</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:29px">
<span class="sliderDesc" style="margin-left:62px">Lower Bit Limit</span>
<input type="checkbox" id="apply3" class="applyBox"/>
<span id="loLimVal" class="currVal">30</span>
<input type="range" class="vertSlider" id="loLim" min="2" max="200" step="1" value="10"/>
<span class="topVal" style="margin-left:60px">10000</span>
<span class="minVal" style="margin-left:82px">2</span>
<div class="sliderBg"></div>
</div>
<div class="sliderBox" style="margin-left:117px">
<span class="sliderDesc" style="margin-left:55px; font-size:10.5px">Lower Frequencies</span>
<input type="checkbox" id="apply4" class="applyBox"/>
<span id="impFreqVal" class="currVal">800Hz</span>
<input type="range" class="vertSlider" id="impFreq" min="0" max="200" step="1" value="80"/>
<span class="topVal" style="margin-left:66px">2kHz</span>
<span class="minVal" style="margin-left:71px">0Hz</span>
<div class="sliderBg"></div>
</div>
<div style="position:relative; white-space:normal; margin-left:-7px; display:inline-block; width:300px">
<span class="selectDesc" style="margin-left:157px; margin-top:20px">Transient detect<br>sensitivity:</span>
<select id="transientField" style="width:90px; margin-top:6px; margin-left:160px">
<option value="0">None</option>
<option value="1">Low</option>
<option value="2" selected>Moderate</option>
<option value="3">Extreme</option>
</select>
<span class="selectDesc" style="margin-left:157px; margin-top:9px">Group size:</span>
<select id="subbandField" style="width:90px; margin-top:2px; margin-left:160px">
<option value="0">4</option>
<option value="1" selected>8</option>
<option value="2">16</option>
<option value="3">32</option>
</select>
<span class="selectDesc" style="margin-left:157px; margin-top:8px">Keyframe interval:</span>
<select id="keyframeField" style="width:90px; margin-top:2px; margin-left:160px">
<option value="0">0.5s</option>
<option value="1">1s</option>
<option value="2" selected>2s</option>
<option value="3">5s</option>
<option value="4">10s</option>
<option value="5">30s</option>
</select>
<span class="selectDesc" style="margin-left:162px; margin-top:8px">Adaptive alloc</span>
<input type="checkbox" id="adaptAllocApply" class="applyBox" style="margin-left:-2px; position:relative; display:inline-block; margin-top:10px" checked/>
</div>
</div>
<div style="position:relative; display:inline-block; text-align:center">
<span style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:8px">Bitrate Monitor</span>
<canvas id="monitor" width="2000" height="250" style="width:660px; height:85px; background-color:#373737; border:2px solid white; border-radius:2px; margin-top:-1px; display:block; padding:4px; cursor:crosshair"></canvas>
<span id="monCurrent" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Current: ---</span>
<span id="monAverage" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Average: ---</span>
<span id="monCursor" style="font-size:13px; font-family:Verdana; color:#fff; display:inline-block; vertical-align:top; margin-top:3px; width:160px">Cursor: ---</span>
</div>
</div>
</div>
<div class="contentBox" id="metaBox" style="width:300px; height:385px; margin-top:1%; margin-left:20px; padding:10px">
<input id="meta0" type="text" placeholder="Title" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta1" type="text" placeholder="Artist" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta2" type="text" placeholder="Album" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta3" type="text" placeholder="Genre" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta4" type="text" placeholder="Year" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<input id="meta5" type="text" placeholder="Track" autocomplete="off" spellcheck="false" maxlen="254" class="metaData"/>
<span style="font-size:16px; margin-top:20px; display:inline-block; vertical-align:top; cursor:default">Load metadata from file</span>
<label class="slider" style="margin-top:17px; margin-left:4px">
<input type="checkbox" id="autoLoad" class="hide" checked/>
<span class="switch"></span>
</label>
<span style="font-size:16px; margin-top:17px; margin-left:53px; display:inline-block; vertical-align:top; cursor:default">Include metadata</span>
<label class="slider" style="margin-top:14px; margin-left:4px">
<input type="checkbox" id="inclMeta" class="hide" checked/>
<span class="switch"></span>
</label>
</div>
</div>
</body>
</html>